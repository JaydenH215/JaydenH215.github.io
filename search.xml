<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈BLE地址、隐私机制、白名单、定向广播]]></title>
    <url>%2F2020%2F06%2F01%2F%E6%B5%85%E8%B0%88BLE%E5%9C%B0%E5%9D%80%E3%80%81%E9%9A%90%E7%A7%81%E6%9C%BA%E5%88%B6%E3%80%81%E7%99%BD%E5%90%8D%E5%8D%95%E3%80%81%E5%AE%9A%E5%90%91%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[想要BLE slave做到“只允许指定设备连接”，可通过隐私机制、白名单、定向广播来实现，但是它们的概念是什么，互相之间是什么关系，以及如何起作用的，这篇笔记用于解答这些疑惑。 前言最近工作上遇到了相关问题，趁这次机会整理一番。 首先介绍在BLE中地址、隐私机制、白名单、定向广播的概念，不完整，只需形成感性认识。 然后介绍各功能内部实现以及对外接口，加深认识。 最后参考nimble协议栈源码，slave在发送广播包和接收到连接请求包时在不同上下文所做的处理。 目录 1. 术语 2. 概念简介 2.1. 地址 2.2. 隐私机制 2.3. 白名单 2.4. 定向广播 3. 详细说明 3.1. 隐私机制 3.1.1. 隐私机制的内部实现 3.1.2. 隐私机制的对外接口 3.2. 白名单 3.2.1. 白名单的内部实现 3.2.2. 白名单的外部接口 3.3. 定向广播 3.3.1. 定向广播内部实现 3.3.2. 定向广播外部接口 4. 协议栈实现分析 4.1. 发送广播包 4.1.1. 广播包策略a 4.1.2. 广播包策略b 4.1.3. 广播包策略c 4.2. 接收连接请求包 4.2.1. 接收连接请求包策略a 4.2.2. 接收连接请求包策略b 4.2.3. 接收连接请求包策略c 4.2.4. 接收连接请求包策略d 4.2.5. 定向广播策略 5. 参考资料 1. 术语 dev addr：device address，设备地址，也有叫MAC地址。 rpa：resolvable private address，可解析的私人地址。 irk：identity resolving key，用于生成rpa 2. 概念简介2.1. 地址讨论白名单、隐私机制、定向广播总是绕不开BLE地址，所以笔者结合自己理解总结一下BLE地址的一些性质。 BLE细分共有4种地址： public addr——向IEEE花钱买的全球唯一地址，设备上电后，断电前地址的值不会随着时间变化 random static addr——芯片随机生成的地址，设备上电后，断电前地址的值不会随着时间变化 random non-resolvable private addr——设备上电后，每隔一段时间根据随机数生成的随机地址，所以断电前地址的值会随着时间变化 random resolvable private addr——设备上电后，每隔一段时间根据irk和随机数生成的随机地址，所以断电前地址的值会随着时间变化 基于上述4个地址，可以衍生出device addr概念，device addr分为public device addr和random device addr两种。分别对应：public addr和random static addr、random non-resolvable private addr、random resolvable private addr。 可以这么表述： 手机系统蓝牙列表扫描到了附近很多蓝牙设备的device addr，其中那边那个手环的device addr现在就是个public地址。 手机系统蓝牙列表扫描到了附近很多蓝牙设备的device addr，其中那边那个手环的device addr现在就是个random static地址。 手机系统蓝牙列表扫描到了附近很多蓝牙设备的device addr，其中那边那个手环的device addr现在就是个random non-resolvable private addr地址。 手机系统蓝牙列表扫描到了附近很多蓝牙设备的device addr，其中那边那个手环的device addr现在就是个random resolvable private addr地址。 基于上述2个不会随着时间而变化地址，可以衍生出identity addr概念，identity addr分为public identity addr和random identity addr两种。分别对应：public addr和random static addr。 可以这么表述： 这个手环的device addr现在是一个public addr，它的identity addr也是一个public addr。 这个手环的device addr现在是一个random static addr，它的identity addr也是一个random static addr。 这个手环的device addr现在是一个random resolvable private addr，这种地址的值老是变来变去，不过手环的identity addr不会变，是一个public addr。 这个手环的device addr现在是一个random resolvable private addr，这种地址的值老是变来变去，不过手环的identity addr不会变，是一个random static addr。 2.2. 隐私机制如果某某的智能手环的device addr是identity addr，非法分子一旦把“device addr”和“某某”对应起来，就可以通过蓝牙的层面来非法跟踪某某了，即跟踪固定device addr的广播包，这种情况可以认为隐私（privacy）被侵犯了。解决方法就是用random resolvable private addr作为device addr，这样就算不小心泄露了一次deviceaddr，后面非法分子也没办法长时间通过蓝牙的层面来跟踪某某。 2.3. 白名单某某买了一个智能手环，第一件事是将手机和手环进行配对绑定（pairing &amp; bonding），目的是将手机和手环关联起来，将手机添加进手环的白名单（white list），以后白名单以外的手机都无法与手环设备建立连接，白名单相当于一个过滤器（filter）。 2.4. 定向广播有天某某到楼下取快递，但是手机落在家里了，这个时候手机和手环因为距离太远而断开了连接。此时手环便会发送一种低占空比定向广播（low duty cycle connectable directed advertising），希望刚刚断连的那台手机（specific device）收到广播后能够重新发起连接，因为手环和手机断开前在做重要的交互动作，所以这个重连需求并不急迫。某某回到家之后，手机重连手环，此时发现手机app收到手环新版本升级的推送，便点击升级手环，由于信号不稳定，升级过程中手机和手环再次断开了连接，这时候手环便会发送一种高占空比定向广播（high duty cycle connectable directed advertising），即广播包发的很频繁，希望刚刚断连的那台手机能够尽快发起连接，继续完全断开前的升级固件动作，这个需求很急迫。 3. 详细说明3.1. 隐私机制3.1.1. 隐私机制的内部实现隐私机制内部维护一个resolving list，resolving list是一个entry数组。 每个entry都有自己的privacy mode和peer irk，这两个元素影响了controller如何处理收到的空中包: peer irk != all-zero device privacy mode：不管是否已有peer irk，同时接受peer identity addr和peer rpa的空中包 network privacy mode：如果已有peer irk，则只接受peer rpa的空中包 peer irk == all-zero 只接受peer identity addr的空中包 12345678910111213141516171819202122struct ble_ll_resolv_data&#123; uint8_t addr_res_enabled; //使能/禁能地址解析 uint8_t rl_size; //resolving list最大entry个数 uint8_t rl_cnt; //resolving list目前已使用的entry个数 uint32_t rpa_tmo; //rpa更新超时时间 struct ble_npl_callout rpa_timer;&#125;;struct ble_ll_resolv_entry&#123; uint8_t rl_addr_type; //public or random static uint8_t rl_reserved; uint8_t rl_priv_mode; //network mode(default) or device mode uint8_t rl_local_irk[16]; uint8_t rl_peer_irk[16]; uint8_t rl_identity_addr[BLE_DEV_ADDR_LEN]; uint8_t rl_local_rpa[BLE_DEV_ADDR_LEN]; //controller内部写，hci只能读 uint8_t rl_peer_rpa[BLE_DEV_ADDR_LEN]; //controller内部写，hci只能读&#125;;struct ble_ll_resolv_entry g_ble_ll_resolv_list[BLE_LL_RESOLV_LIST_SIZE]; 3.1.2. 隐私机制的对外接口 隐私机制 功能 备注 广播rpa使能/禁能 通过HCI的LE Set Advertising Parameters command的Own_Address_Type field 地址解析使能/禁能 通过HCI的LE Set Address Resolution Enable command，不影响广播rpa的生成，但如果收到rpa，则会有影响 添加entry 通过HCI的LE Add Device To Resolving List command。因为添加的是identity addr，所以从resolving list角度来看，有public addr和random static addr两种。 移除entry 通过HCI的LE Remove Device From Resolving List command 清空resolving list 通过HCI的LE Clear Resolving List command 查询entry count 通过HCI的LE Read Resolving List Size command 查询peer entry rpa 通过HCI的LE Read Peer Resolvable Address command 查询local entry rpa 通过HCI的LE Read Local Resolvable Address command 设置rpa更新时间 通过HCI的LE Set Resolvable Private Address Timeout command 设置entry的privacy mode 通过HCI的LE Set Privacy Mode command 3.2. 白名单3.2.1. 白名单的内部实现白名单是一个entry数组，添加进白名单的是dev addr，所以添加进去的有可能是4种细分地址的任意一种。 12345678struct ble_ll_whitelist_entry&#123; uint8_t wl_valid; //当前entry是否有效 uint8_t wl_addr_type; //public or random uint8_t wl_dev_addr[BLE_DEV_ADDR_LEN];&#125;;struct ble_ll_whitelist_entry g_ble_ll_whitelist[BLE_LL_WHITELIST_SIZE]; 3.2.2. 白名单的外部接口 白名单 功能 备注 使能/禁能 通过HCI的LE Set Advertising Parameters command的Advertising_Filter_Policy field 添加entry 通过HCI的LE Add Device To White List command。因为添加的是dev addr，所以从白名单角度来看，有public addr和random addr两种。 移除entry 通过HCI的LE Remove Device From White List command 查询entry count 通过HCI的LE Read White List Size command 清空白名单 通过HCI的LE Clear White List command 3.3. 定向广播3.3.1. 定向广播内部实现略 3.3.2. 定向广播外部接口 定向广播 功能 备注 使能/禁能 通过HCI的LE Set Advertising Parameters command的Advertising_Type field、Peer_Address_Type field、Peer_Address field 4. 协议栈实现分析从slave的两个角度来分析，一个是发送广播包（ADV_IND/ADV_DIRECT_IND）视角，一个是接收到连接请求包（CONNECT_REQ）视角。 4.1. 发送广播包 Own_Address_Type取值 保留 备注 BLE_HCI_ADV_OWN_ADDR_PUBLIC（0） 参考广播包策略a BLE_HCI_ADV_OWN_ADDR_RANDOM（1） 参考广播包策略a BLE_HCI_ADV_OWN_ADDR_PRIV_PUB（2） 参考广播包策略b BLE_HCI_ADV_OWN_ADDR_PRIV_RAND（3） 参考广播包策略c 4.1.1. 广播包策略a广播包中的adv addr设置为public addr或random addr，取决于Own_Address_Type是0还是1。 如果是定向广播，广播包中的target addr为LE Add Device To Resolving List command设置的peer addr（dev addr）。 4.1.2. 广播包策略b根据LE Add Device To Resolving List command设置的peer addr（identity addr）去resolving list找对应的local irk，找到且如果不为all-zero，则生成local rpa，覆盖广播包中的adv addr，否则用public addr作为adv addr。 如果是定向广播，根据LE Add Device To Resolving List command设置的peer addr（identity addr）去resolving list找对应的peer rpa，找到且peer irk不是all-zero则覆盖广播包中的target addr；如果找不到或找到但peer irk是all-zero，则用peer addr（identity addr）覆盖广播包中的target addr。 4.1.3. 广播包策略c根据LE Add Device To Resolving List command设置的peer addr（identity addr）去resolving list找对应的local irk，找到且如果不为all-zero，则生成local rpa，覆盖广播包中的adv addr，否则用random addr作为adv addr。 如果是定向广播，根据LE Add Device To Resolving List command设置的peer addr（identity addr）去resolving list找对应的peer rpa，找到且peer irk不是all-zero则覆盖广播包中的target addr；如果找不到或找到但peer irk是all-zero，则用peer addr（identity addr）覆盖广播包中的target addr。 4.2. 接收连接请求包slave是否能够建立连接，跟上述三个功能紧密联系，只要其中一个功能拒绝建立连接，就会导致无法建立连接。在收到连接请求包之后执行流程如下图，因为这三个功能都不是必须的，所以用虚线表示： 下面是不同上下文下的具体情况： addr_res_enabled取值 Advertising_Filter_Policy取值 备注 0 BLE_HCI_ADV_FILT_NONE（0） 参考接收连接请求包策略a 0 BLE_HCI_ADV_FILT_CONN（2） 参考接收连接请求包策略b 1 BLE_HCI_ADV_FILT_NONE（0） 参考接收连接请求包策略c 1 BLE_HCI_ADV_FILT_NONE（2） 参考接收连接请求包策略d 4.2.1. 接收连接请求包策略a谁都能和local dev正常建立连接，controller不会去解析请求包中的init addr，所以内部解析标志位resolved_flg = 0。 4.2.2. 接收连接请求包策略b只有请求包中的init addr是白名单里面其中一个dev addr才可以和local dev建立连接，controller不会去解析init addr，所以解析标志位resolved_flg = 0。 4.2.3. 接收连接请求包策略c如果请求包的init addr是rpa，那么controller主动解析请求包中的init addr。解析过程为：用请求包中的init addr和resolving list中的peer irk来计算rpa，如果rpa等于请求包中的init addr，则认为解析成功；否则认为解析失败。 请求包中的init addr是rpa 如果解析成功，则resolved_flg = 1 将这次的init addr（rpa）更新到resolvling list的对应rl_peer_rpa 可正常建立连接 如果解析失败，则resolved_flg = 0 可正常建立连接 请求包中的init addr是identity addr 请求包中的init addr在resolving中，且是network mode，且peer irk不是all-zero，则拒绝建立连接。 其他情况均可正常建立连接 4.2.4. 接收连接请求包策略d如果请求包的init addr是rpa，那么controller主动解析请求包中的init addr。解析过程为：用请求包中的init addr和resolving list中的peer irk来计算rpa，如果rpa等于请求包中的init addr，则认为解析成功；否则认为解析失败。 请求包中的init addr是rpa 如果解析成功，则resolved_flg = 1 将这次的请求包中的init addr（rpa）更新到resolvling list的对应rl_peer_rpa 可正常建立连接 如果解析失败，则resolved_flg = 0 拒绝建立连接 请求包中的init addr是identity addr 如果请求包中的init addr在resolving中，且是network mode，且peer irk不是all-zero，则拒绝建立连接。 其他情况均可正常建立连接 白名单检索 如果resolved_flg == 1 在g_ble_ll_whitelist中找init addr对应的peer identity addr，如果找到则可正常建立连接，否则拒绝建立连接。 如果resolved_flg == 0 在g_ble_ll_whitelist中找init addr，如果找到则可正常建立连接，否则拒绝建立连接。 4.2.5. 定向广播策略如果是使用定向广播，则还会有最后一道门槛，过了这道门槛之后，才真正允许建立连接。如果是非定向广播，则没有这部分的内容。 如果resolved_flg == 1 如果LE Set Advertising Parameters command设置的Peer_Address和请求包中的init addr在resolving list中对应的peer identity addr相同，则允许建立连接，否则拒绝建立连接。 如果resolved_flg == 0 如果LE Set Advertising Parameters command设置的Peer_Address和请求包中的init addr相同，则允许建立连接，否则拒绝建立连接。 5. 参考资料 《Core_v5.2》 nimble源码]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电路基础——基本概念、定律和定理（0）]]></title>
    <url>%2F2020%2F04%2F05%2F%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%AE%9A%E5%BE%8B%E5%92%8C%E5%AE%9A%E7%90%86%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本功越扎实，心里才越踏实。 前言这次学习的目标和原因： 硬件是个人职业短板，需要突破。 学的不扎实，知识碎片化，需要建立框架。 能够分析围绕mcu的外围电路，比如各种电源电路。 主要教材是《电路基础（原书第6版）》作者: [美]Charles K.、Matthew N.O.Sadiku 著；段哲民、周巍、李宏 译，网络资料辅助，还有一个数位板做笔记。 学习方法是：理解概念、建立框架、跳过习题、具体问题具体分析。 目录 基本概念 电荷 电流 电压 功率 能量 定律原理方法定理 公理（axiom） 定律（law） 定理（theorem） 原理（principle） 基本定律 欧姆定律 电荷守恒定律（law of conservation of charge） 基尔霍夫电流定律（KCL） 能量守恒定律（law of conservation of energy） 基尔霍夫电压定律（KVL） 基本原理 分压原理（principle of voltage division） 分流原理（principle of current division） 电路电量分析方法 电路定理 叠加定理（superposition theorem） 戴维南定理（Thevenin’s theorem） 诺顿定理（Norton’s theorem） 求戴维南/诺顿等效电路 参考资料 基本概念我们研究的是电路，这里面的各种被研究的量，我们称为“电量”，具体有以下5个基本电量概念。 电荷 电荷是构成物质的原子的一种电气特性，单位是库伦（C）。原子由原子核和电子组成。电子所带的电荷e是负的，其电荷量为1.602*10^-19C。 电流 电流是指电荷的时间变化率，单位为安培（A）。1A即表示：给定一点（该点可以是端点、元件、横截面），单位时间(即1秒）流过该点的电荷多少。 电压 电压是指移动单位电荷通过某个元件所需的能量，单位是伏特（V）。Uab = 1V即表示：给定两点a、b，将单位电荷（即1库存电荷）的电子从b点移动到a点所需要的能量，也可以说是指将单位电荷的质子从a点移动到b点所需的能量。 功率 功率是消耗或吸收能量的时间变化率，单位是瓦特（W）。1W即表示：N电荷量的电子在1秒内从b点移动到a点所需要的能量是1J。 能量 能量是指做功的能力，单位为焦耳（J）。电力公司以瓦特·小时（W·h）为单位度量能量，其中：1W·h = 3600J。1J即表示：看成是某种量，不懂能量是什么。 定律原理方法定理公理（axiom）是经过受逻辑限制的证明为真的陈述（一般在数学中，只有重要或有趣的陈述才叫定理）。最终不用再解释的基础。这个基础被认为是显而易见的，不言自明的。 定律（law）是由不变的事实规律所归纳出的结论，是对客观事实的一种表达形式，是通过大量具体的客观事实经验累积归纳而成的结论。 定理（theorem）由公理，原理，定律经过数学推导得出的结论。基于公理，可以推倒出方便使用的定理。 原理（principle）既可以表示law or rule，又可以表示theory，应该不是一个正式的科学术语。 基本定律欧姆定律材料阻碍电流的能力称为“电阻”。电阻两端的电压v与流过该电阻的电流i成正比。 电荷守恒定律（law of conservation of charge）电荷既不能被创造，也不能被消灭，只能转移。因此一个系统中电荷量的代数和是不变的。 基尔霍夫电流定律（KCL） 流入任一节点(或任一闭合界面)的电流代数和为零。基尔霍夫电流定律是基于电荷守恒定律。 能量守恒定律（law of conservation of energy）任何时刻电路中功率的代数和必须为零。 基尔霍夫电压定律（KVL） 任何闭合类路径（或回路）上全部电压的代数和为零。 基本原理分压原理（principle of voltage division）串联电阻，电源电压在各电阻之间的电压分配与各电阻的阻值成正比，电阻值越大，电阻上的电压越大。 分流原理（principle of current division）并联电阻，总电流被多个支路分享，且支路电流与电阻值成反比，较小电阻的支路流过较大的电流。 电路电量分析方法 节点分析法 如果要分析包含晶体管电路，需要先画出等效电路才能用节点分析法。因为晶体管各点电位不一样，所以不能用节点分析法。 网孔分析法 用于直接分析包含晶体管的电路，可以直接使用网孔分析卡。 应用叠加定理 优点是分析时简化电路，缺点是计算步骤多了。可用于三极管交直流信号分析。 电源变换 基础是等效的概念，等效电路是指与原电路具有相同的u-i特性的电路。通过电源变换将戴维南定理和诺顿定理关联起来。 电路定理 线性电路 下面介绍的两个定理仅适用于线性（liner）电路，线性电路含有比例性和叠加性。 比例性是指：如果输入（也称为激励）乘以一个常数，那么输出（也称为响应）也相应第乘以同一个常数。如电阻的电压和电流关系。 叠加性是指：各个输入之和的响应等于每个输入单独作用于系统时的响应之和。如电阻的电压和电流关系。 叠加定理（superposition theorem） 线性电路是叠加定理的基础。线性电路中元件两端电压（或流经元件的电流）是每个独立源单独作用下在该元件两端产生的电压（或流经元件的电流）的代数和。 戴维南定理（Thevenin’s theorem） 戴维南定理是指：线性二端电路可以用一个由电压源VTh和与之串联的电阻RTh组成的等效电路所替代，其中VTh为端口的开路电压，RTh为独立源关闭时端口的输入（或等效）电阻。 诺顿定理（Norton’s theorem） 诺顿定理是指：线性二端电路可以由电流源IN和与之并联的电阻RN构成的等效电路替代，其中IN为流过端口的短路电流，RN为独立电流源关闭时端口的输入电阻（或等效）电阻。 求戴维南/诺顿等效电路 求a-b两端的开路电压u或者短路电流i 所有独立源关闭时，a-b两端的输入电阻r 即通过开路测试和短路测试，就足以求出至少包含一个独立源电路的戴维南等效电路或诺顿等效电路。 参考资料 公理，原理，定律，定理的区别与关系——现代科学的基础 怎么区分和理解定理、定律、理论、概念、效应、规则、原理？]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈BLE吞吐量]]></title>
    <url>%2F2020%2F01%2F02%2F%E6%B5%85%E8%B0%88BLE%E5%90%9E%E5%90%90%E9%87%8F%2F</url>
    <content type="text"><![CDATA[怎样才能提高BLE吞吐量？一文读懂BLE的吞吐量。 前言减少连接间隔是唯一提高BLE传输速率方法吗？ATT_MTU会影响传输速率吗？长包指的是什么？这篇文章就是解答这些问题的，有不对的地方，欢迎斧正。 由于影响吞吐量的因素有许多，而篇幅有限，以下条件先不考虑： 加密数据包 加密数据包会影响LL PDU的长度。 att protocol以外的l2cap channel 比如smp这种对吞吐量没有需求的channel就不考虑。 link layer丢包重发 同一个LL packet发多遍当然会影响吞吐量，这里假设射频环境很好，不会有这个影响。 le coded phy 只考虑1M和2M cpu处理速度的影响 假设cpu处理速度足够快，不会被其他中断影响协议栈的行为。 hci通讯接口的吞吐量限制 hci接口有uart/spi/ram等多种通讯方式，不同通讯方式本身也会有速率限制，这里不考虑这个限制。 多链路 多链路分时复用radio，吞吐量会被降低，这里只考虑单链路情况。 目录 1. BLE协议栈框架 2. GATT 3. ATT PROTOCOL 3.1. Write Command format 3.2. Handle Value Notification format 3.3. ATT_MTU的定义 4. L2CAP SPEC 4.1. SDU(Service Data Unit) 4.2. B-frame 4.3. MTU(Maximum Transmission Unit), min 23 4.4. MPS(Maximum PDU payload Size), max 65535 4.5. Segmentation and Reassembly 4.6. Fragmentation and Recombination 5. LINK LAYER 5.1. Link layer packet 5.1.1. ble4.0 5.1.2. ble4.2 5.2. BLE连接传输原理说明 6. PHY LAYER 1M PHY和2M PHY的差异 7. 总结 8. 参考资料 1. BLE协议栈框架 手机下传write without repsonse的一个procedure数据流向： gatt(client) -&gt; l2cap -&gt; hci(option) -&gt; link layer -&gt; phy -&gt; phy -&gt; link layer -&gt; hci(option) -&gt; l2cap -&gt; gatt(server) 设备上传notication的一个procedure数据流向： gatt(server) -&gt; l2cap -&gt; hci(option) -&gt; link layer -&gt; phy -&gt; phy -&gt; link layer -&gt; hci(option) -&gt; l2cap -&gt; gatt(client) 2. GATT gatt规定ATT_MTU默认支持不能小于23。ATT_MTU理论最大65535（因为MTU Exchange Request里面表示ATT_MTU大小的MTU size field只有2个字节）。 但是在BLUETOOTH SPECIFICATION Version 5.0 | Vol 3, Part F 3.2.9 Long Attribute Values有这么一句话：The maximum length of an attribute value shall be 512 octets。 所以是规范已经限制了attribute value只有512字节？如果是这样的话，那么再大的ATT_MTU其实也没有意义。 12345678nimble关于attribute value和ATT_MTU部分的代码：#define BLE_ATT_ATTR_MAX_LEN 512/** * An ATT MTU of 527 allows the largest ATT command (signed write) to contain a * 512-byte attribute value. */#define BLE_ATT_MTU_MAX 527 ATT_MTU = 512，attr value length = 512，刚好一包一个notification ATT_MTU = 527, attr value length = 512, 刚好一包一个signed write contain a 512-byte attr value ATT_MTU = 64, attr value length = 512，发N包prepare write request和一包excute write request gatt要求l2cap channel默认配置参数如下： 表格中MTU是一个默认值，表示此时此刻att protocol channel的L2CAP payload支持的最大传输单元是23字节，但并不代表local设备最大接收能力。连接之后可以通过exchange mtu procedure来更新ATT_MTU，所以协商ATT_MTU过程相当于协商MTU的过程，与BR/EDR的差异是BR/EDR通过l2cap channel configuration procedure来配置MTU，而不是exchange mtu procedure。 3. ATT PROTOCOL3.1. Write Command format 用于gatt的write without response。 3.2. Handle Value Notification format 用于gatt的notifications。 3.3. ATT_MTU的定义ATT_MTU is defined as the maximum size of any packet sent between a client and a server. A higher layer specification defines the default ATT_MTU value. ATT_MTU is a negotiated value. 连接之后，client可以向server发起mtu exchange procedure，即client告诉server自己的最大接收能力ATT_MTU（client’s local att protocol channel MTU），server也会告诉client自己的最大接收能力ATT_MTU（server’s local att protocol channel MTU），最后取两者的最小值为这条通道的ATT_MTU（actual att protocol channel MTU）。 4. L2CAP SPEC4.1. SDU(Service Data Unit)来自上层的数据，不包含任何l2cap的信息，这里为ATT的消息。 4.2. B-frame ATT PROTOCOL的数据就放在b-frame的information payload中，Length field占2个字节，所以理论payload最大只有65535字节，因为受芯片的ram大小限制，实际实现还会再小一点，通过MTU具体实现表现出来。 4.3. MTU(Maximum Transmission Unit), min 23MTU is not a negotiated value, it is an informational parameter that each device can specify independently and indicates to the remote device that the local device can receive, in this channel, an MTU larger than the minimum required. l2cap MTU表示每条l2cap channel的最大接收能力，不是一个协商值。 当l2cap channel是att protocol channel的时候，协议栈实现如下： 比如说，local设备的local att protocol channel MTU最大能支持到2048字节，但是peer设备的local att protocol channel MTU只能支持到23字节，经过gatt的mtu exchange procedure之后，取两者的最小值23为这条通道的ATT_MTU（即actual att protocol MTU）。尽管这时候att protocol作了长度限制不能超过23字节，但是peer设备要是发送了非法长度数据，att protocol本身是没有机制去检测出来的。所以在mtu exchange procedure之后协议栈实现就需要将local设备的att protocol channel MTU更新为23，那么当local设备收到一包att protocol消息之后，在l2cap层就可以判定该数据包是合法长度的数据了。 所以att protocol channel MTU也常常被误认为是ATT_MTU，但他们还是有点区别的。 4.4. MPS(Maximum PDU payload Size), max 65535规范规定在Basic L2CAP mode的B-frame的MPS等于MTU。 Note: In the absence of segmentation, or in the Basic L2CAP Mode, the Maximum Transmission Unit is the equivalent to the Maximum PDU payload Size and shall be made equal in the configuration parameters. 4.5. Segmentation and Reassembly 当MPS小于MTU的时候，需要segmentation；但是对于ATT消息, MPS总是等于ATT_MTU，所以ATT消息从不需要segmented，但是可能会因为链路层限制而需要fragmented。 经典蓝牙某些场合可能需要用到segmented，不太清楚。 4.6. Fragmentation and Recombination 由于链路层的接收限制，l2cap的帧有时候需要拆开发送，用链路层包头的LLID来负责标识拆包和重组。 下面看两个例子。 如果BLE4.0，ATT_MTU最后client和server协商出来结果是23，那么发送20字节（ATT_payload）不需要拆包： 1字节前导码 + 4字节访问地址 + 2字节链路帧头（其中LLID = 10b，表示一个没有fragmentation的完整包） + 4字节L2CAP帧头 + 3字节ATT帧头 + 20字节的ATT_payload + 3字节CRC 如果BLE4.0，ATT_MTU最后client和server协商出来假设是63，那么你发送60字节数据（ATT_payload），L2CAP会将它拆成3包（拆包的原因是因为BLE4.0链路层PDU的限制），最终从空中发出去的包长这样： 1）1字节前导码 + 4字节访问地址 + 2字节链路帧头（其中LLID = 10b，表示这是第一个连续包） + 4字节L2CAP帧头 + 3字节ATT帧头 + 20字节的ATT_payload + 3字节CRC 2）1字节前导码 + 4字节访问地址 + 2字节链路帧头（其中LLID = 01b，表示这是下一包连续包） + 27字节的ATT_payload + 3字节CRC 3）1字节前导码 + 4字节访问地址 + 2字节链路帧头（其中LLID = 01b，表示这是最后一个连续包） + 13字节的ATT_payload + 3字节CRC 上面10b、01b中的“b”表示二进制格式，中间的包和最后的包的LLID都是01b，对方怎么知道什么时候收完包呢？靠的是第一包的4字节L2CAP帧头，这里面会说明后面一共有多少数据待接收。 5. LINK LAYER5.1. Link layer packet5.1.1. ble4.0 可以看到LL PDU的长度最大为39字节，LL PDU又分为两种：一种是ADV PDU广播通道包，最大长度为39个字节；另一种是DATA PDU数据通道包，最大为33字节，后者是连接之后通讯的数据包。 展开DATA PDU，前2个字节为帧头，后4个字节为MIC（用于加密），就算不加密这4个字节也不能用于传输上层数据，即payload最多能容纳27字节的上层数据（上层指的是l2cap层）。 The Length field of the Header indicates the length of the Payload and MIC if included. The length field has the range of 0 to 31 octets. The Payload field shall be less than or equal to 27 octets in length. The MIC is 4 octets in length. 5.1.2. ble4.2后来因为27字节payload实在太少了，所以在ble4.2引入了新的特性，即LE data length extension（数据长度扩展，业内也叫长包）。 可以看到LL PDU的长度最大为257字节，LL PDU又分为两种：一种是ADV PDU广播通道包，最大长度为257个字节；另一种是DATA PDU数据通道包，最大为257字节，后者是连接之后通讯的数据包。 展开DATA PDU，前2个字节为帧头，后4个字节为MIC（用于加密），就算不加密这4个字节也不能用于传输上层数据，即payload最多能容纳251字节的上层数据（上层指的是l2cap层）。 The Length field of the Header indicates the length of the Payload and MIC if included. The length field has the range of 0 to 255 octets. The Payload field shall be less than or equal to 251 octets in length. The MIC is 4 octets in length 5.2. BLE连接传输原理说明 上图为 BLE 连接传输的一个例子，其中每个 Connection Event 包含 6 个主机和 6 个从机的 Link Layer Packet，一个 Connection Interval 只有一个 Connection Event；如果每个 Link Layer Pakcet 限制最多包含 20 字节用户数据，那么上图例子中每次 Connection Interval， BLE主机最多可以发送 120 字节用户数据， BLE 从机最多可以发送 120 字节用户数据。而这个Connection Interval 就是我们常说的“连接间隔”。所以可知， BLE链路层传输速率的快慢主要由以下因素决定： Connection Interval 的大小； 每个 Connection Event 可以发送多少个 Link Layer Packet； 每个 Link Layer Packet 可以负载多少用户数据； 相邻 Link Layer Packet之间的时间间隔T_IFS。 6. PHY LAYER 上图为1M PHY和2M PHY在2404频点发送数据0b1010的对比图。 BLE的调制方式为GFSK，BLE定义在信道中传输的是二进制符号（波形），即1个符号（波形）表示1个比特，其中相对频点正偏代表数字基带信号1，相对频点负偏的代表数字基带信号0。 之所以速率提高了，本质应该是2M PHY的码长变小了，即发送一个符号（波形）所需的时间变小了。 BLE规范原文：A binary one shall be represented by a positive frequency deviation, and a binary zero shall be represented by a negative frequency deviation.1M PHY： The mandatory symbol rate is 1 megasymbol per second (Msym/s), where 1 symbol represents 1 bit therefore supporting a bit rate of 1 megabit per second (Mb/s), which is referred to as the LE 1M PHY2M PHY： An optional symbol rate of 2 Msym/s may be supported, with a bit rate of 2 Mb/s, which is referred to as the LE 2M PHY. 1M PHY和2M PHY的差异 1M PHY的正偏和负偏至少需要达到185Khz，2M PHY的正偏和负偏至少需要达到370Khz 2M PHY的比特率是1M PHY的两倍，即2M PHY传输完0b1010的时间是1M PHY的一半 7. 总结提高吞吐量的途径有以下几种方式： GATT client用write without response而不要用write characteristic value server用notification而不要用indication ATT_MTU尽可能大（这样可以减少L2CAP的帧头数量，通过Fragmentation来尽可能占据带宽，提高吞吐量） L2CAP NULL（应用层没啥可以做的） LINK LAYER 减少连接间隔（connection interval） 增大连接事件（connection event） 启用数据包扩展特性（link layer packet） PHY LAYER 启用2M PHY特性（BLE5.0可选特性） 8. 参考资料 《RW-BLE-HOST-SW-FS_2mbps》 《Core_v5.0》 nimble源码 《ZLG52810P0-1-TC透传模块速率参考手册 V1.01》 波特率和比特率及吞吐率三者概念 《通信原理》曹丽娜-西安电子科技大学-第一章、第六章 BLE 5 之 物理层 《RF-PHY.TS.5.0.3》]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈BLE中的cortexm编译链接]]></title>
    <url>%2F2019%2F12%2F17%2F%E6%B5%85%E8%B0%88BLE%E4%B8%AD%E7%9A%84cortexm%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[针对笔者用过的几款BLE芯片，谈谈对cortexm编译链接的理解。 前言有不正确的地方，欢迎各位大佬斧正。 目录 1. 适用范围 2. 简介 2.1. 文件的来龙去脉 2.2. o和.axf的关系 3. 地址视图 3.1. 大型操作系统平台（CPU从RAM取指令跑代码） 3.2. Nordic（CPU从Flash取指令跑代码） 3.3. Chipsea/Nxp（CPU开始从ROM取指令，后面从RAM取指令跑代码） 3.4. On Semi/BlueX（CPU开始从ROM取指令，后面从RAM取指令跑代码，也能从FLASH取指令跑代码） 4. 脚本文件 4.1. ld（gcc的ld用） 4.2. sct（keil的armlink用) 5. 参考资料 1. 适用范围 希望了解object、axf、bin文件在整个生成代码过程中的地位； 希望了解芯片的链接脚本作用； 谈谈对VMA和LMA的理解； 针对gcc的ld文件和keil的sct文件简单谈谈自己的理解。 2. 简介网上有不少关于分散加载文件（sct）以及链接脚本文件（ld）的介绍，其中也会涉及到许多编译原理的概念，但大部分针对PC，感觉都有点支离破碎，无法跟自己手上芯片平台对上，这里简单谈一下当前对这部分的理解，方便以后复习。 2.1. 文件的来龙去脉.c -&gt; .s -&gt; .o -&gt; .axf -&gt; .bin 由.c编译成.s，再由.s汇编成.o，然后由linker将各个.o链接成.axf（可执行文件），最后由objcopy/fromelf抽取.axf中的各种（output section），生成.bin。 2.2. o和.axf的关系使用linux虚拟机简单写一个c文件，然后用gcc生成对应的.o和.axf文件。 objdump可以查看elf格式文件的section的反汇编，这里我们比较.o和.axf的main部分，从而了解链接器将.o文件变成.axf过程中进行了什么加工。 在链接之前，.o的.text section中的main部分是0x00000000，这是因为在未进行空间地址分配之前，.o的.text section起始地址就是0x00000000，这时候的地址只是一个保留值，链接时候会用一个有意义的虚拟内存地址（VMA）覆盖。 为生成.axf文件，除了test.o，linker还会将一些库文件也加进来。Linker负责给这些代码分配空间和地址，图上的最后结果是main部分被分配到0x00400526（VMA），printf也有了虚拟内存地址。对于程序来说，他会到自己的虚拟地址空间（VMA）取指令，然后执行。 链接过程我们关心主要的是：地址和空间分配（Address and Storage）和重定位（Relocation）。 3. 地址视图gcc ld中的LMA类比armlink中的load address gcc ld中的VMA类比armlink中的excution address 后面一般使用LMA和VMA说明相关内容。 3.1. 大型操作系统平台（CPU从RAM取指令跑代码）对于类似Linux这种大型操作系统来说： 可以将编译链接后生成的.axf（可执行文件）文件保存在系统中的磁盘中； 当用户需要运行.axf里面程序的时候，是不需要生成.bin文件的，直接根据磁盘中.axf的文件头将程序通过loader加载到LMA中（RAM），如果是普通PC电脑LMA=VMA，也就是说，程序被加载到RAM什么地方，也就在什么地方运行，这时候把.axf里面的ENTRY地址（VMA）传递给PC寄存器，就可以直接运行程序了。 3.2. Nordic（CPU从Flash取指令跑代码） 与上一个例子不一样，这里的CPU从flash取指令并执行（XIP），而不会先拷贝到RAM才运行，一般CortexM应用是不会用到loader的，那这种情况怎么跑程序呢？以上图为例： 最简单的方法就是将.axf文件中的RW section和ZI section扣出来烧写进RAM中对应的VMA，将RO section烧写进FLASH中对应的VMA。但是这样做只要掉电，RAM里面的数据就丢失了，需要再次下载，单单这一个原因就否决这种做法了。 将.axf文件中的RO section烧写进FLASH中对应的VMA，然后将RW section和ZI section也烧进FLASH，让程序在刚开始运行的时候，在启动文件中将RW section和ZI section搬到RAM中对应的VMA，然后正式开始执行，这种做法便是最普遍的使用方式。（一般ZI section不会烧写进flash，会在启动文件中直接赋0） 有人会问，LMA去哪里了？LMA一开始是应用在大型OS上，用于加载程序的，但是CortexM并不会加载程序（没跑linux系统），所以在这种情况下，LMA似乎有了不一样的作用。针对第2种方式，大家都希望最终烧进FLASH的是代码紧凑，占空间尽量小的.bin文件，那么这个.bin文件又是怎么得到的？一般情况下，.bin文件是objcopy工具从.axf文件中将一部分内容扣出来组成的，objcopy的指令选项可以指定需要扣的section，如下图所示。 那么这些section在.bin中是如何分布是谁决定的呢？ 没错，就是LMA！objcopy从最开始section的LMA开始，一直复制到到最尾section的LMA，中间没有代码的地方补0，最后生成.bin文件，也就是说对于这种情况，可以将.bin文件看成是LMA空间。 整个过程的顺序是： 用工具链生成.axf文件； 然后用其他外部工具（例如objcopy）将.axf的RO section，RW section根据各自的LMA扣出来，组成一个.bin文件； 然后通过烧录工具，直接将.bin烧写到芯片的flash那里去。（一般是FLASH的起始地址） 假设向量表映射到flash的地址0x00000，在烧写完.bin之后，芯片上电，CortexM内核决定了PC寄存器的值会从0x00004去取（也就是RO section的第二字），并开始执行程序，在程序开始执行之后不久，启动文件中的程序（若是keil则是__main函数）又会将LMA中的RW section移到VMA中，因为RO section的LMA等于VMA，所以不需要搬。有一个概念很重要：“LMA”中RO、RW的所在地址都是临时的，他们所在的真正位置（即链接时候设置的地址值）都必须在程序初始化时由相应程序，将他们移动到相应的虚拟地址（如果LMA！=VMA）。 3.3. Chipsea/Nxp（CPU开始从ROM取指令，后面从RAM取指令跑代码） 某些特别的CortexM应用跑代码是在RAM上跑的（也即从RAM上获取指令执行），当这样使用的时候一般芯片内部会有一个固化bootloader（存放在芯片ROM中的一段代码）来充当类似loader的角色。 整个过程的顺序是： 用工具链生成.axf文件； 然后用其他外部工具（例如objcopy）将.axf的RO section，RW section根据各自的LMA扣出来，组成一个.bin文件； 然后通过烧录工具，直接将.bin烧写到“bootloader指定的flash地址”。 假设向量表映射到ROM的某个位置P，在烧写完.bin之后，芯片上电，CortexM决定了PC寄存器的值会从ROM中的P+0x0004取，这个PC值会导致跳到固化的bootloader中运行，然后在bootloader中会把“bootloader指定的flash地址”中的.bin文件搬运到“LMA中，即上图Load View中的0x00000”，然后将PC寄存器的值指向第二个字，也就是RO section的第二字（0x00004），并开始执行程序，在程序开始执行之后不久，启动文件中的程序（若是keil则是__main函数）又会将LMA中的RW移到VMA中，因为RO section的LMA等于VMA，所以不需要搬。 3.4. On Semi/BlueX（CPU开始从ROM取指令，后面从RAM取指令跑代码，也能从FLASH取指令跑代码） 某些特别的CortexM应用跑代码是在RAM上跑的（也即从RAM上获取指令执行），当这样使用的时候一般芯片内部会有一个固化bootloader（存放在芯片ROM中的一段代码）来充当类似loader的角色。可以看见这里是直接从FLASH中的代码拷贝到RAM中运行的，大小相等，但是实际FLASH的大小一般比RAM大很多，而RAM的价格又很贵，所以需要一种方法实现“少容量的RAM+大容量的FLASH”的组合，这里就引入了一个叫Cache的东西。 整个过程的顺序是： 用工具链生成.axf文件； 然后用其他外部工具（例如objcopy）将.axf的RO section，RW section根据各自的LMA扣出来，组成一个.bin文件,将剩余section中的一部分扣出来，组成另一个.bin文件； 然后通过烧录工具，直接将一部分.bin烧写到“bootloader指定的flash地址”； 烧录工具将另外一部分.bin烧写到“Cache Controller指定的flash地址”。 假设向量表映射到ROM的某个位置P，在烧写完.bin之后，芯片上电，CortexM决定了PC寄存器的值会从ROM中的P+0x0004取，这个PC值会导致跳到固化的bootloader中运行，然后在bootloader中会把“bootloader指定的flash地址”中的.bin文件搬运到“LMA中，即上图Load View中的0x00000”，然后将PC寄存器的值指向第二个字，也就是RO section的第二字（0x00004），并开始执行程序，在程序开始执行之后不久，启动文件中的程序（若是keil则是__main函数）又会将LMA中的RW移到VMA中，因为RO section的LMA等于VMA，所以不需要搬。当在执行RO section代码时，有某条语句（Code1）需要访问B地址的代码，这时候总线便访问B地址的代码，这个会被映射到Cache Controller识别，Cache Controller从C地址将B地址的代码读出来，存放到自己的Cache RAM中，同时告诉Code1。下一次有其他代码（Code2）希望访问B地址的代码时候，就直接Cache RAM中的代码直接返回，而如果Code2访问Cache RAM中不存在的B地址区域其他代码，Cache Controller则会重新到C地址去寻找对应代码。通过这个机制，动态的修改Cache RAM的内容，实现“少容量的RAM+大容量的FLASH”组合。 4. 脚本文件4.1. ld（gcc的ld用） location counter与VMA有直接关系，与LMA无直接关系，具体看VMA和LMA在ld.pdf中的定义。ld脚本文件中location counter的增加和减少，要考虑VMA的变化而不是LMA的变化。 决定LMA的主要因素有三个：AT、指定VMA、memory region，当这三个因素都不存在的时候，LMA=VMA。（优先级好像是：AT &gt; 指定VMA &gt; memory region，不确定是不是会有优先级关系） 4.2. sct（keil的armlink用) Region是armlink的术语，gcc没有这样的说法。 Load region的root region（第一个excution region）是不会被搬运的，也就是说这部分等价于LMA=VMA（LMA和VMA在gcc中用于section，这里用于region只是类比一下）。 Armlink会给每个region（load region+ execution region）做一些标号，用$$表示。 当使用.sct文件控制链接过程时： The linker generates Image$$region_name symbols for every execution region present in the image（执行视图的地址） The linker generates Load$$ region_name symbols for every execution region present in the image（加载视图的地址） The linker generates Load$$LR$$load_region_name symbols for every load region present in the image（这部分加载视图和执行视图的地址是一样的） 不使用.sct文件控制链接过程时： ER_RO, for the read-only execution region.（默认region名字） ER_RW, for the read-write execution region. （默认region名字） ER_ZI, for the zero-initialized execution region. （默认region名字） Image$$RO$$Base（与section相关的标号，注意section和region区别） Image$$RW$$Base（与section相关的标号，注意section和region区别） Image$$ZI$$Base（与section相关的标号，注意section和region区别） 基于C库实现STACK和HEAP分配，参考《DUI0377G_02_mdk_armlink_user_guide》第7.1.4章节 __at指令好像是指到VMA而不是LMA，跟gcc相反 用fromelf文件将elf文件转化成.bin，参考《DUI0459F_02_mdk_fromelf_user_guide》，对于多个load region，会导致产生多个.bin文件，一般需要另外将他们合并。 5. 参考资料 《程序员的自我修养》 《杜云海的arm学习报告系列》 《DUI0377G_02_mdk_armlink_user_guide》 《DUI0459F_02_mdk_fromelf_user_guide》 《ld》 《GCC的链接脚本学习笔记》 《VMA vs LMA?》]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ble</tag>
        <tag>cortexm</tag>
        <tag>链接脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据转换]]></title>
    <url>%2F2019%2F12%2F10%2Fpython%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[整理一下写python小工具的数据转换常用方法。 前言优先使用py标准库的方法 目录 1. Built-in Types 1.1. int 1.1.1. int.to_bytes(length, byteorder, *, signed=False) 1.1.2. int.from_bytes(bytes, byteorder, *, signed=False) 1.2. str 1.2.1. str.encode(encoding=”utf-8”, errors=”strict”) 1.2.2. str.isascii() 1.2.3. str.isdecimal() 1.3. bytes 1.3.1. bytes.fromhex(string) 1.3.2. hex() 1.3.3. bytes.decode(encoding=”utf-8”, errors=”strict”) 1.3.4. bytes.isascii() 2. Other Std Libs 2.1. struct 2.1.1. format 2.1.2. struct.pack(format, v1, v2, …) 2.1.3. struct.pack_into(format, buffer, offset, v1, v2, …) 2.1.4. struct.unpack(format, buffer) 2.1.5. struct.unpack_from(format, buffer, offset=0) 2.2. binascii [2.2.1. binascii.hexlify(data, sep[, bytes_per_sep=1]]) 2.2.2. binascii.unhexlify(hexstr) 3. 参考资料 1. Built-in Types1.1. int1.1.1. int.to_bytes(length, byteorder, *, signed=False)Return an array of bytes representing an integer. 123456789&gt;&gt;&gt; (1024).to_bytes(2, byteorder='big')b'\x04\x00'&gt;&gt;&gt; (1024).to_bytes(10, byteorder='big')b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'&gt;&gt;&gt; (-1024).to_bytes(10, byteorder='big', signed=True)b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'&gt;&gt;&gt; x = 1000&gt;&gt;&gt; x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')b'\xe8\x03' 1.1.2. int.from_bytes(bytes, byteorder, *, signed=False)Return the integer represented by the given array of bytes. 12345678910&gt;&gt;&gt; int.from_bytes(b'\x00\x10', byteorder='big')16&gt;&gt;&gt; int.from_bytes(b'\x00\x10', byteorder='little')4096&gt;&gt;&gt; int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)-1024&gt;&gt;&gt; int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)64512&gt;&gt;&gt; int.from_bytes([255, 0, 0], byteorder='big')16711680 1.2. str1.2.1. str.encode(encoding=”utf-8”, errors=”strict”)Return an encoded version of the string as a bytes object. 1234&gt;&gt;&gt; 'w435g'.encode()b'w435g'&gt;&gt;&gt; type('w435g'.encode())&lt;class 'bytes'&gt; 1.2.2. str.isascii()Return True if the string is empty or all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. 1.2.3. str.isdecimal()Return True if all characters in the string are decimal characters and there is at least one character, False otherwise. Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character in the Unicode General Category “Nd”. 1.3. bytes1.3.1. bytes.fromhex(string)This bytes class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. 12&gt;&gt;&gt; bytes.fromhex('2Ef0 F1f2 ')b'.\xf0\xf1\xf2' 1.3.2. hex()Return a string object containing two hexadecimal digits for each byte in the instance. 12&gt;&gt;&gt; b'\xf0\xf1\xf2'.hex()'f0f1f2' If you want to make the hex string easier to read, you can specify a single character separator sep parameter to include in the output. By default between each byte. A second optional bytes_per_sep parameter controls the spacing. Positive values calculate the separator position from the right, negative values from the left. 1234567&gt;&gt;&gt; value = b'\xf0\xf1\xf2'&gt;&gt;&gt; value.hex('-')'f0-f1-f2'&gt;&gt;&gt; value.hex('_', 2)'f0_f1f2'&gt;&gt;&gt; b'UUDDLRLRAB'.hex(' ', -4)'55554444 4c524c52 4142' 1.3.3. bytes.decode(encoding=”utf-8”, errors=”strict”)Return a string decoded from the given bytes. 123456789&gt;&gt;&gt; value = b'\xf0\xf1\xf2'&gt;&gt;&gt; value.decode()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf0 in position 0: invalid continuation byte&gt;&gt;&gt; value = b'\x30\x31\x32'&gt;&gt;&gt; value.decode()'012' 1.3.4. bytes.isascii()Return True if the sequence is empty or all bytes in the sequence are ASCII, False otherwise. ASCII bytes are in the range 0-0x7F. 2. Other Std Libs2.1. struct标准库介绍链接 This module performs conversions between Python values and C structs represented as Python bytes objects. This can be used in handling binary data stored in files or from network connections, among other sources. 2.1.1. format Format C Type Python Type Standard size x pad byte no value c char bytes of length 1 1 b signed char integer 1 B unsigned char integer 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 s char [] bytes 2.1.2. struct.pack(format, v1, v2, …)Return a bytes object containing the values v1, v2, … packed according to the format string format. The arguments must match the values required by the format exactly. 2.1.3. struct.pack_into(format, buffer, offset, v1, v2, …)Pack the values v1, v2, … according to the format string format and write the packed bytes into the writable buffer buffer starting at position offset. Note that offset is a required argument. 2.1.4. struct.unpack(format, buffer)Unpack from the buffer buffer (presumably packed by pack(format, …)) according to the format string format. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes must match the size required by the format, as reflected by calcsize(). 2.1.5. struct.unpack_from(format, buffer, offset=0)Unpack from buffer starting at position offset, according to the format string format. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes, starting at position offset, must be at least the size required by the format, as reflected by calcsize(). 2.2. binascii2.2.1. binascii.hexlify(data[, sep[, bytes_per_sep=1]])Return the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data. Similar functionality (but returning a text string) is also conveniently accessible using the bytes.hex() method. If sep is specified, it must be a single character str or bytes object. It will be inserted in the output after every bytes_per_sep input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative bytes_per_sep value. 123&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(b'\xb9\x01\xef', '-')b'b9-01-ef' 2.2.2. binascii.unhexlify(hexstr)Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of hexlify(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise an Error exception is raised. Similar functionality (accepting only text string arguments, but more liberal towards whitespace) is also accessible using the bytes.fromhex() class method. 12&gt;&gt;&gt; binascii.unhexlify(b'3094')b'0\x94' 3. 参考资料 Python 3中bytes/string的区别 Python 3官方文档 python3 byte,int,str转换 python 字符串，bytes和hex字符串之间的相互转换]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——controller（7）]]></title>
    <url>%2F2019%2F12%2F02%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94controller%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[多角度学习controller，uml还不熟练，欢迎斧正。 前言只学习slave部分，master可以根据slave的思路去看。 目录 1. 伪系统框图 2. 用例图 3. 类图 4. 状态图 5. 时序图 6. MISC 7. 总结 1. 伪系统框图笔者觉得正常的系统框图不能表现每个组件之间的关系，所以加上一些箭头来表示controller涉及到的组件，箭头指向被调用的组件。 2. 用例图 用用例图简单描述系统的功能需求是一个不错的工具，controller的功能比图中的要多，但是我们只针对图中的几个重点功能展开学习，其他细枝末节有需要再看。 3. 类图 ble_ll_sched 芯片的射频收发器只有一个，但是ble支持多链路共存，就会存在不同链路竞争同一个射频收发器的情况，这时候就需要一个调度器来做仲裁者的角色，决定某个时刻的射频资源释放给哪个链路，这个就是“射频时间片调度器”。 ble_ll_conn和ble_ll_conn_sm 其中一种竞争射频收发器的链路就是“连接链路”；那么这些连接链路有什么异同呢？相同的地方就是这些链路收发数据的方法，断开连接的方法都是通用的，差异的地方就是每个链路的连接参数、跳频表、状态标示位等是不一样的。 所以把ble_ll_conn看成是ble_ll_conn_sm类的方法集合，而ble_ll_conn_sm就是包含不同属性的实例。 ble_ll_adv和ble_ll_adv_sm 另外一种竞争射频收发器的链路就是“广播链路”；同上，但是目前不讨论ble5.0的情况，所以不会同时存在两条广播链路，即只有一个ble_ll_adv_sm实例。 4. 状态图 ble4.1之后链路层支持多链路共存，每个链路都有可能处于上图5个状态中的1个，在协议栈刚初始化完成时，每个链路都处于默认状态，也就是STANDBY状态，通过下面的状态图来了解默认状态下的链路是如何转换成广播链路和连接链路的。 作图工具是Quantum Leaps,LLC公司的产品——qm，有兴趣的可以看我github之前做的简介。 因为复杂，所以笔者根据个人理解做了一些简化，UML图中部分语法会与实际源码有所违背，但是整体框架是一样的，实际应以源码为准。 广播链路 实际上广播链路还有很多细枝末节，但是这里只抓重点了解，所以通过上面的状态图可分析的有限场景如下： STANDBY状态下host通过hci调用ble_ll_adv_sm_start启动广播 广播状态下，收到无效包 广播状态下，收到扫描请求包，发送扫描响应包 广播状态下，收到连接请求包 在一个广播事件中，切换下一个广播通道 当前广播事件结束，切换下一个广播事件 在各个状态下host通过hci调用ble_ll_adv_sm_stop停止广播 连接链路 实际上连接链路还有很多细枝末节，但是这里只抓重点了解，所以通过上面的状态图可分析的有限场景如下： 创建连接成功，但建立连接失败 应答和流控机制 无上层数据发送，即发送EMPTY PDU 有上层数据发送，即发送L2CAP message 收到peer有效数据包，发送到上层 在一个连接事件中，切换TX/RX 当前连接事件结束，切换下一个连接事件 supervision超时断开 5. 时序图推荐wnnwoo前辈的nimble相关文章，图本并茂分析的很好。 6. MISC 关于从射频时间片调度器申请到的时间片 一个时间片用一个“广播事”或“连接事件”来表述，每个事件中可能包含一个或多个发送、接收射频数据的过程，比如：某个广播事件从调度器申请到t1-t2时刻的射频资源，那么在t1-t2期间既有发送广播包，也有接收扫描请求包和接收连接请求包的过程。 7. 总结controller确实复杂，理解起来难免忽略了许多细节，但是无碍，这次学习nimble了解controller的实现细节目的达到了，以后工作中遇到什么问题，也应该知道怎么在源码中找到答案了。 关于host部分以后有时间再看吧，估计最近都不会花太多时间在nimble上了，毕竟又有了新的学习目标了哈哈哈。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mcu异常FAQ]]></title>
    <url>%2F2019%2F11%2F29%2Fmcu%E5%BC%82%E5%B8%B8FAQ%2F</url>
    <content type="text"><![CDATA[FAQ 前言未完。 目录 1. 死机 2. 功耗异常 IO异常 1. 死机 jlink访问mcu 观察晶振的频率和波形，对比正常片 示波器抓VCC动态波形 测电流判断mcu当前运行模式 静电测试 重复上下电死机，通过复位判断是否也能复现，排除电源影响 防存在外部电容导致没完全下电程序跑飞，上电前先短接VCC和GND放电（小电容） 悬空问题样片排除其他外部通讯干扰 PLL/DLL稳定时间不足，从内部时钟切换到PLL/DLL时钟，主频出问题 2. 功耗异常 与正常片的功耗对比 各个引脚的二极管特性 各个引脚的电阻 回炉FT 观察DC-DC输出电压动态波形，开关导致电流异常 观察VCC动态波形 IO异常 EOS/ESD 过压 latch-up（待定）]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>mcu</tag>
        <tag>异常</tag>
        <tag>死机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BQB认证]]></title>
    <url>%2F2019%2F11%2F28%2FBQB%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[整理一下BQB认证相关资料，方便跟认证机构沟通。 前言大部分内容参考乐鑫公众号的一篇介绍BQB认证的文章。 目录 1. 简介 2. 认证类型 2.1. component 2.2. subsystem 2.3. end product 2.4. 总结 3. 认证流程 3.1. QDID 3.2. DID 3.3. 总结 4. 认证方案 4.1. 做模块，以后需要被其他产品引用 4.2. 做产品，包含模块，无须layout rf部分 4.3. 做产品，包含芯片，重新layout rf部分 4.4. 蓝牙dtm模式/信令模式 1. 简介BQB全称bluetooth qualification body，如果产品希望在包装、广告以及整个营销过程中使用蓝牙文字标志及蓝牙徽标，产品都要通过BQB认证。 2. 认证类型2.1. component认证软件层面上的东西，不包含硬件。 最小认证单元，不能被DID直接引用 可以被subsystem和end product combine 如有需要，可以修改重新测试 实际认证案例： host（搜索QDID：122684） controller（搜索QDID：） linklayer（搜索QDID：122146） 2.2. subsystem认证完整的系统，包含软件硬件。 一个完整的子系统，可以被DID直接引用 可以直接做测试，也可以combine已做过认证的component 实际认证案例： host subsystem（搜索QDID：119517） controller subsystem（搜索QDID：101395） profile subsystem（搜索QDID：） 2.3. end product 必须是一个完整系统（包括host+controller+硬件），可以被DID直接引用。 可以直接做测试，也可以combine已做过认证的component 如有需要可以修改测试项，重新测试 2.4. 总结一个能够通过BQB认证的蓝牙设备肯定是以下其中一种： subsystem设备：reference各种subsystem，可能会combine各种component end product设备：直接测试end product，可能会combine各种component 3. 认证流程BQB认证中有两类ID，一类称为QDID（Qualified Design ID），另一类称为DID（Declaration ID），QDID可以被DID引用。 3.1. QDID获得这个ID需要经过测试机构一系列的测试。 3.2. DID用钱买这个ID 3.3. 总结一个能够通过认证的蓝牙设备肯定拥有至少一个QDID，一个DID，其中拥有QDID的方式可以是： reference旧的QDID 重新认证一个新的end product的QDID，然后reference这个新的QDID 重新认证一个新的subsystem的QDID，然后reference这个新的QDID 一个DID可以reference一个或多个QDID，一个QDID可以被一个或多个DID reference。 使用DID好处是可以使终端厂商的认证过程简单化。 4. 认证方案4.1. 做模块，以后需要被其他产品引用 认证测试一个新的host component QDID（或者combine一个已过测试的host component的QDID） 认证测试一个新的controller/linklayer component QDID（或者combine一个已过测试的controller/linklayer component的QDID） 认证测试一个新的end product的QDID 4.2. 做产品，包含模块，无须layout rf部分 买一个DID reference模块的end product QDID 4.3. 做产品，包含芯片，重新layout rf部分 买一个DID 认证测试一个新的host component QDID（或者combine一个已过测试的host component的QDID） 认证测试一个新的controller/linklayer component QDID（或者combine一个已过测试的controller/linklayer component的QDID） 认证测试一个新的end product的QDID 4.4. 蓝牙dtm模式/信令模式做BQB认证需要烧录dtm固件，然后用蓝牙综测仪接设备，进行测试。 dtm模式的蓝牙设备和蓝牙综测仪有hci和2-wire两种接口协议，需要确认dtm固件支持哪种协议，在蓝牙综测仪上面要选对配置。 测试机构说的信令模式一般是hci接口协议。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>BQB</tag>
        <tag>认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——phy（6）]]></title>
    <url>%2F2019%2F11%2F07%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94phy%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[主要介绍phy层的射频工作机制。 前言物理层与芯片本身强相关，这里仅分析nrf52的phy层调度相关内容。 目录 1. 术语 2. 总览 2.1. 框图 2.2. 广播调度例子 3. phy对象的内部属性 3.1. xcvr clock settle time 3.2. various radio timings 3.2.1. ramp-up times 3.2.2. delay between EVENTS_READY and start of tx 3.2.3. delay between EVENTS_END and end of txd packet 3.2.4. delay between rxd access address and EVENTS_ADDRESS 3.2.5. delay between end of rxd packet and EVENTS_END 4. phy对象的对外方法 4.1. ble_phy_tx_set_start_time 4.2. ble_phy_rx_set_start_time 4.3. ble_phy_set_txend_cb 4.4. ble_phy_tx 4.5. ble_phy_rx 4.6. ble_phy_rxpdu_copy 5. phy对象使用其他对象的方法 5.1. ble_ll_rx_start 5.2. ble_ll_rx_end 5.3. ble_ll_state_get 5.4. ble_ll_wfr_timer_exp 6. phy对象的内部实现 6.1. 概述 6.1.1. 在指定的时刻发送射频数据 6.1.2. 在指定的时刻接收射频数据，若在后续指定时间段内没收到，则认为接收超时，若收到则传递给上层处理 6.1.3. 切换射频发送和射频接收 6.2. 详细说明 7. 补充说明 7.1. 时间补偿 7.2. radio数据包配置 8. 关闭timer0的时机 9. 总结 1. 术语 wfr：wait for response（用于计算radio rx超时时间） xcvr：transceiver（发射接收器） ll：link layer（链路层） 2. 总览2.1. 框图phy对象内部会使用其他对象的方法。 2.2. 广播调度例子下图是一个广播例子，简单展示了phy对象对内对外是如何协同工作，完成调度的。 3. phy对象的内部属性3.1. xcvr clock settle time因为需要保持低功耗，所以不需要使用xcvr时候，应该将其时钟也一同关闭，当需要在某个时刻再次打开xcvr时候，需要考虑时钟的settle time，即需提前先打开xcvr时钟。 3.2. various radio timingsradio外设相关的延时 3.2.1. ramp-up timesramp-up times即操作射频收发寄存器后，直到真正发出射频信号或者已准备好接收射频信号的所需时间。 需考虑这部分时间确保在预定时刻发送射频信号。 3.2.2. delay between EVENTS_READY and start of tx产生EVENTS_READY后，到真正开始发送射频信号的延时。 因为启动射频是由ppi+radio+timer0+rtc0来联动的，即timer0时间到触发RADIO-&gt;TASKS_TXEN，然后延时ramp-up time，接着产生EVENTS_READY，由于radio short，直接TASKS_START。需考虑这部分时间确保在预定时刻发送射频信号。 3.2.3. delay between EVENTS_END and end of txd packet产生EVENTS_END后，到真正发送完射频信号的延时。 切换成接收/关闭射频时，需考虑这部分时间确保射频数据发送完整，防止发送数据断尾。 3.2.4. delay between rxd access address and EVENTS_ADDRESS收到合法access addr到产生EVENTS_ADDRESS的延时。 当启动radio接收超时定时器时，需考虑这部分时间，确保在指定时间内真的没有收到合法的access addr。 当计算当前数据包何时被捕获时，需考虑这部分时间，用于反推。 3.2.5. delay between end of rxd packet and EVENTS_END接收一包结束到产生EVENTS_END的延时。 当从接收切换成发送，计算上一次捕获到数据包最后一个bit的时刻，然后增加T_IFS启动发送，需考虑这部分时间确保在预定时刻发送射频信号。 4. phy对象的对外方法4.1. ble_phy_tx_set_start_timenimble中射频发射有两种应用场景： rx结束，根据T_IFS切换到tx 链路层发起tx 第1中情况会在phy的ble_phy_rx_end_isr中实现，而第2种实现就是调用ble_phy_tx_set_start_time函数了，该函数用于设定一个定时时间（粗略定时rtc0+精准定时timer0），radio会在该时刻发送preamble的第一个bit。 4.2. ble_phy_rx_set_start_timenimble中射频接收有两种应用场景： tx结束，根据T_IFS切换到rx 链路层发起rx 第1中情况会在phy的ble_phy_tx_end_isr中实现，而第2种实现就是调用ble_phy_rx_set_start_time函数了，该函数用于设定一个定时时间（粗略定时rtc0+精准定时timer0），radio会在该时刻开始接收射频数据。 4.3. ble_phy_set_txend_cb该函数输入参数有一个是函数指针，在ble_phy_tx_end_isr中打钩子函数，用于通知链路层发送结束。 4.4. ble_phy_tx用于配置射频发送的参数，比如发送buffer、radio的shortcut配置和发送结束后是否需要自动切换到rx，但是不会真正启动射频发送。 4.5. ble_phy_rx用于配置射频接收的参数，比如接收buffer，radio的shortcut配置，但是不会真正启动射频接收。 4.6. ble_phy_rxpdu_copy用于获取上一次phy rx的pdu数据。 5. phy对象使用其他对象的方法5.1. ble_ll_rx_start收到pdu第一个字节之后，phy调用该方法，根据pdu的第一个字节即pdu type，来决定是否继续接收下面的帧，以及接收完应该如何处理。 5.2. ble_ll_rx_end收完一帧，开始处理这一帧，phy根据该方法返回结果判断是否要切换到tx，还是关闭射频外设。 5.3. ble_ll_state_get获取当前链路层的状态，封装进ble mbuf header，在ble_ll_rx_end中调用，让链路层知道传递上去的帧是在哪个状态时接收到的。 5.4. ble_ll_wfr_timer_exp如果接收超时，就会调用该函数。比如，在37信道发送可连接可发现广播，切换到接收后，没有在指定时间内收到CONNECT_IND或者SCAN_REQ，就会调用这个函数。 6. phy对象的内部实现内部实现主要涉及isr和ppi、timer0、rtc0，下面先介绍它们之间的关系，然后分别介绍每个中断和外设的功能作用，最后举例在一些常见应用场景中是如何协同工作的。 6.1. 概述phy核心功能可以用以下几句话总结： 在指定的时刻发送射频数据。 在指定的时刻接收射频数据，若在后续指定时间段内没收到，则认为接收超时，若收到则传递给上层处理。 切换射频发送和射频接收 6.1.1. 在指定的时刻发送射频数据将指定时刻拆成尽可能多的省电系统时钟tick和一个耗电精准时钟tick，rtc0的CC[0]设置为省电tick，timer0的CC[0]设置为耗电tick。 当rtc0的CC[0]事件触发时，配合ppi启动timer0。当timer0的CC[0]事件触发时，配合ppi启动射频发送。 6.1.2. 在指定的时刻接收射频数据，若在后续指定时间段内没收到，则认为接收超时，若收到则传递给上层处理将指定时刻拆成尽可能多的省电系统时钟tick和尽可能少的耗电精准时钟tick，rtc0的CC[0]设置为尽可能多的省电tick，timer0的CC[0]设置为尽可能少的耗电tick。将接收超时事件拆成N个耗电精准时钟tick，timer0的CC[3]设置为N个耗电tick。 当rtc0的CC[0]事件触发时，配合ppi启动timer0。当timer0的CC[0]事件触发时，配合ppi启动射频接收。当timer0的CC[3]事件触发时，配合ppi关闭射频接收。 6.1.3. 切换射频发送和射频接收 链路层在启动射频发射时会设置g_ble_phy_data.phy_transition变量，在phy的ble_phy_tx_end_isr中会根据该变量判断下一步是切换到rx，还是关闭射频外设。 在ble_ll_wfr_timer_exp或ble_phy_rx_end_isr中会把接收结果传递给链路层，链路层决定下一步是切换到tx，还是关闭射频外设。 6.2. 详细说明 ble_phy_rx_start_isr：收到access addr以及第一个字节后，使能RADIO_INTENSET_END_Msk中断。 ble_phy_rx_end_isr：接收一帧后会进入该分支，传递给链路层刚刚收到的那一帧。 ble_ll_wfr_timer_exp：接收超时会进入该分支，表示指定时间内没收到有效数据包。 ble_phy_tx_end_isr：发送玩一帧后会进入该分支，通知链路层发送完成，判断下一步是切换到rx，还是关闭射频外设。 ch4：当收到rx的RADIO-&gt;EVENT_ADDRESS时，触发NRF_TIMER0-&gt;TASKS_CAPTURE[3]，取消wfr定时器。 ch5：当收到NRF_TIMER0-&gt;EVENTS_COMPARE[3]，即wfr定时器超时，则触发NRF_RADIO-&gt;TASKS_DISABLE，关闭射频。 ch20：当收到TIMER0-&gt;EVENTS_COMPARE[0]时，触发RADIO-&gt;TASKS_TXEN，即通过timer0来硬件自动打开射频发射。 ch21：当收到TIMER0-&gt;EVENTS_COMPARE[0]时，触发RADIO-&gt;TASKS_RXEN，即通过timer0来硬件自动打开射频接收。 ch26：当收到tx/rx的RADIO-&gt;EVENT_ADDRESS时，触发TIMER0-&gt;TASK_CAPTURE[1]，因为ADDRESS域是固定长度，所以可以用来计算捕获tx/rx时刻。 ch27：当收到tx/rx的RADIO-&gt;EVENT_END时，触发TIMER0-&gt;TASK_CAPTURE[2]，用于捕获tx/rx结束（即收到CRC域最后一个bit）时刻。 ch31：当收到RTC0-&gt;EVENTS_COMPARE[0]时，触发TIMER0-&gt;TASKS_START，即通过RTC0来控制启动timer0，具体为用户指定一个时刻（RTC0 tick + timer0 us），当收到RTC0-&gt;EVENTS_COMPARE[0]时，说明tick（31us/tick）已经计算完成，打开timer0计算剩下的时间（1us/tick）。 7. 补充说明7.1. 时间补偿cpu_time和rem_usecs，cpu_time表示从调用函数到目标时刻需要的tick个数，rem_usecs表示除了cpu_time之外，还需要多少个us才能达到目标时刻，且rem_usecs应该小于31。cpu_time与rtc外设有关，rem_usecs与timer外设有关。 7.2. radio数据包配置123456789101112#define NRF_LFLEN_BITS (8) //对应pdu header的8位lsb#define NRF_S0LEN (1) //对应pdu header的8位msb#define NRF_S1LEN_BITS (0) //这个域的长度为0，即舍弃该域#define NRF_MAXLEN (255) //对应pdu payload#define NRF_BALEN (3) //对应llpkt的4字节access address#define NRF_PCNF0 (NRF_LFLEN_BITS &lt;&lt; RADIO_PCNF0_LFLEN_Pos) | \ (RADIO_PCNF0_S1INCL_Msk) | \ (NRF_S0LEN &lt;&lt; RADIO_PCNF0_S0LEN_Pos) | \ (NRF_S1LEN_BITS &lt;&lt; RADIO_PCNF0_S1LEN_Pos)#define NRF_PCNF0_1M (NRF_PCNF0) | \ (RADIO_PCNF0_PLEN_8bit &lt;&lt; RADIO_PCNF0_PLEN_Pos) //对应llpkt的1字节preamble 8. 关闭timer0的时机发送完射频数据、接收完一帧射频数据、接收超时之后，都是关闭timer0的时机。 9. 总结还有许多细节没关注到，总体问题不大，后面学习链路层再复习巩固。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈cortexm调试方法]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%B5%85%E8%B0%88cortexm%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当产品出现软件bug，出于各种原因，可能拿不到源码，这时候我们可以让客户提供编译生成的axf和map文件，配合jlink进行软件bug定位。 前言下文内容针对cortex-m内核，欢迎斧正，持续更新。 目录 1. 工具说明 1.1. JLINK 1.2. MAP文件 1.3. AXF文件 2. 参考资料 1. 工具说明1.1. JLINK JLink.exe（J-Link Commander）： 获取cpu环境，推断当前状态 通过r14判断当前是在handler mode还是thread mode 通过pc判断当前是锁死保护还是正常跑飞（锁死保护为0xFFFFFFFE) 通过sp判断栈指针位置，往前推跑飞时的pc 有具体fault标志位的内核型号看一下标志位 如下图cortex-m的例子 J-Mem： 获取ram内容和外设寄存器 判断ram是否正确加载 判断寄存器配置是否正确 如下图gpio翻转的例子。 J-Flash（其它专用flash dump工具）： 获取flash内容 判断flash是否烧录正确位置 判断是否存在误操作擦写 1.2. MAP文件 Image Symbol Table： 判断是否有爆堆栈风险 判断使用到的sram是否开启retention Memory Map of the image： 加载地址：可与flash内容对比判断是否烧录正常 执行地址：提供变量地址给J-Mem Image component sizes： Code (inc. data) RO Data RW Data ZI Data Debug 1.3. AXF文件 反汇编： arm-none-eabi-objdump（gcc工具集）： arm-none-eabi-objdump -S -d xxx.axf &gt; xxx.txt fromelf（keil工具集）： fromelf -c xxx.axf -o xxx.txt 如下图地址0x1fff6258函数的反汇编： NOTE：如果保证编译工程为英文路径，编译器会添加源码路径等信息进axf文件，使得生成的txt文档包含源码。arm-none-eabi-objdump -h可以用来查看是否包含调试信息，如果没有需要在编译时候加入-g选项。 section内容： arm-none-eabi-objdump（gcc工具集）： arm-none-eabi-objdump -D xxx.axf &gt; xxx.txt 2. 参考资料 《UM08001_JLink.pdf》 objdump(Linux)反汇编命令使用指南 《DUI0377G_02_mdk_armlink_user_guide.pdf》 Linux：objdump命令解析]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>cortex-m</tag>
        <tag>内核</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——时钟（5）]]></title>
    <url>%2F2019%2F10%2F29%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[- 前言理解不对的地方欢迎斧正。 nimble的时钟管理主要由以下文件组合实现:hal_timer.c、hal_timer.h、、os_cuptime.h、os_cuptime.c、board.c、npl_os_rtthread.c、nimble_npl.h。 目录 1. 总览 2. controller 2.1. hal_timer.c &amp; hal_timer.h 2.1.1. RTC0计时技巧 2.1.2. RTC0中断处理函数 2.2. os_cputime.c &amp; os_cputime.h 3. host 3.1. board.c 3.2. npl_os_rtthread.c 4. 总结 5. 参考资料 1. 总览 rt-thread和nimble需要用到两类定时器服务：实时性强和实时性弱。 实时性强： controller：需要软件完成实时性和优先级都最高的蓝牙基带内容，如：时间片分配，同步anchor、丢包重发机制等，这时RTC0的中断优先级应该全局最高。 实时性弱： controller：链路层的控制过程，这些对于实时性要求弱。 rt-thread：需要一个系统时钟，这里用RTC1提供时间片。 host：需要用到定时服务叫callout，callout使用rt-thread的一个软件定时器实现（callout在npl_os_rtthread.c文件中实现）。 NOTE：之所以不用Systick而是RTC提供rt-thread系统时钟是因为ble对功耗有要求，RTC功耗更低。 2. controller2.1. hal_timer.c &amp; hal_timer.h基于RTC0和链表实现了软件定时器的功能，即维护一条链表：链表第一个元素即是将要到达的超时事件，第二个为晚一点的超时事件，第三个更晚一点的超时事件。 hal_timer如果有读不明白的地方，可以参考下面两个小节的提示。 2.1.1. RTC0计时技巧 每次RTC0溢出（有效范围bit0~bit23），tmr_cntr += 0x1000000，即通过unsigned int tmr_cntr变量来扩展只有24bit的RTC。 定时器应用可以抽象出这么一种情景，即存在两个时刻，一个为目标时刻，另一个为实时时刻，需要比较这两个时刻谁先谁后。而实时时刻是一直在增加的变量，所以会存在溢出情况，则涉及实时时刻存在溢出情况，与目标时刻比较谁先谁后问题。这里用参考资料的time_after和time_before的方式巧妙解决。 2.1.2. RTC0中断处理函数 RTC溢出 需要进入中断更新计时变量tmr_cntr，若屏蔽这个中断，则无法知道RTC究竟跑了多长时间。 COMPARE置位 当需要延时的时间&lt; 3 tick时候，人工置位COMPARE标志位触发中断 当需要延时的时间≥ 3 tick时候，设置CC寄存器，硬件自动置位COMPARE标志位触发中断。 每次进入RTC0中断都会更新计时变量tmr_cntr，然后判断下一个即将要到达的超时事件事件是否&lt; 3 tick，若成立，则立马调用下一个即将要到达超时事件的cb，否则将CC设置为下一个超时事件的时间。 2.2. os_cputime.c &amp; os_cputime.h基于hal_timer简单封装的一层。 3. host3.1. board.c1234567891011121314151617简化伪代码void RTC1_IRQHandler(void)&#123; ... set_comparator(cur_timer + CYC_PER_TICK); rt_tick_increase(); //rtthread系统时钟tick++ ...&#125;void RTC1_init(void)&#123; ... lfclk_init(); set_comparator(cur_timer + CYC_PER_TICK); ...&#125; 配置lfclk时钟（提供RTCx的时钟源）。 根据设置的rt-thread系统时钟频率来配置RTC1的compare值 每次compare中断将rt-thread系统时钟tick++ 设置下一个compare值 NOTE：需要注意RTC0也依赖lfclk时钟。 3.2. npl_os_rtthread.c该文件主要定义一个简单的事件驱动机制：callout 该组件由定时器、事件、事件队列组成，这些功能在不同平台都具有共性，所以可以抽象出来接口。 callout广泛运用在host中，在controller也有，具体在后面再介绍。 4. 总结时钟抽象分层工作做的很不错，起码时钟这一块需要移植到其他os的东西很清晰。 5. 参考资料 jiffies溢出与时间先后比较—time_after,time_before]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADC相关性能参数概念]]></title>
    <url>%2F2019%2F10%2F23%2FADC%E7%9B%B8%E5%85%B3%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[- 前言补基础 目录 1. 量化误差（Quantization Error） 2. DNL 3. INL 4. 偏移、增益误差（offset、gain error） 5. SNR 6. ENOB 7. ADC的输入阻抗 8. ADC的转换时间 9. 参考资料 1. 量化误差（Quantization Error）用简单3bit ADC来说明。 输入电压被数字化，以8个离散电平来划分，分别由代码000b到111b去代表它们，每一代码跨越Vref/8的电压范围。 代码宽度一般被定义为一个最低有效位（Least Significant Bit，LSB）。 NOTE：code width(n) = v(n+1) - v(n)这里v(n+1)表示输出代码由n跳变为n+1时对应的模拟输入电压，v(n)表示输出代码由n-1跳变为n的模拟输入电压。v(n+1) - v(n)表示输出代码n的代码宽度。 若假定Vref＝8V时，每个代码之间的电压变换就代表1V。如图中橙色线所示，即当输入电压为0.5V或者1.5V时，ADC输出的结果都是1V（001b），这里的误差称为量化误差。 量化误差是±0.5LSB，但是ADC实际的LSB应该参考ENOB而不是分辨率位数。 2. DNLDNL，即微分非线性，表征的是我们ADC的实际刻度与理想刻度之间的差值。 DNL是ADC的相邻代码之间的实际差值与相邻代码之间的理想差值的误差。 比如说我们手中普通的尺子，正常情况下一小格长度应该是标准的1mm。但是由于生产精度，材质，受力引发的形变等影响，尺子上上标注的1小格长度可能并不是标准的1mm，可能是0.98mm，也可能是1.02mm。 比如说我们尺子上的某两个相邻的刻度线之间长度已经变成了0.98mm，那么我们就可以说“A刻度线到B刻度线的DNL是（0.98-1）/1=0.02 LSB”，这里的LSB就是指我们的一个最小刻度对应的长度是多少，对于一般的尺子就是1mm。 将尺子转成ADC，即： 从001b到010b过渡过程的DNL为0LSB，因为刚好为1LSB。 从000b到001b过渡过程就有个0.2LSB的DNL，因为此时有1.2LSB的代码宽度。 NOTE：如果在datasheet中没有清楚说明DNL参数的话，可视该转换器没有漏码，即暗示它有优于±1LSB的DNL。 3. INLINL，即积分非线性，表征的是大信号的线性误差，是指ADC给定输入所包含全部DNL的累计代数和。 INL是ADC的所有代码点上对应的理想模拟量和真实模拟量之间误差最大的那一点的值。 如图，即本来100b对应的理想模拟量是Vref/2，但是真实模拟量介于3Vref/8~4Vref/8，则说这里存在INL误差。出现这种情况的原因。 从整个输出代码来看，每个输入电压代码步距差异累积起来以后和理想值相比会产生一个总差异，这个差异就是非线性积分误差。 NOTE：INL(n) = INL(n-1) + (DNL(n) + DNL(n-1)) / 2即INL(n) = DNL(1) + DNL(2) + ….DNL(n) / 2 4. 偏移、增益误差（offset、gain error）这两个参数主要是用来校准ADC的模拟前端的。 目的是让ADC的编码深度能够最大限度的不压缩额定输入信号的幅度，以减少模拟前端的误差造成的信号损失。 可以简单的理解为： offset是校准模拟前端的准位，要么是0电平的参考点，要么是中间值的参考点； gain是校准模拟前端的信号幅度，也就是输入最大额定信号的编码要对应最大编码值。 这两部分的校准都需要对已知信号进行采样并且与已知信号对应的编码值进行比对，然后调整的，一般是先校准offset，然后校准gain值。当然两个值的校准要用到不同的参考信号。offset与gain是在同一个位置上做的，不需要分先后。 NOTE：若增益误差为11%FSR，根据原始数据测算ADC电压为3V，则需要校准3 * 1.11 = 3.33V 5. SNR信噪比（SNR）就是信号能量和量化噪声能量之比，但是这对于ad来说只是理想情况，即只考虑量化噪声，而实际情况是热噪声，量化噪声以及谐波失真都在干扰信号，于是实际测量AD性能的时候用的更多的是SNDR（信噪失真比），即信号与（热噪声，量化噪声以及谐波失真能量之和）的比值。 可以将量化后的信号进行fft分析后计算得到。这个量用于衡量ADC转换时候信号被噪声影响了多少。 而SFDR（无杂散动态范围）是fft分析频谱中信号幅度与最大谐波之间的距离（可以直接从频谱图中读出），这个距离越大，说明ADC的动态性能越好，就是说转换越接近线性。 一般来说SFDR的值会远大与SNDR，而当趋于理想情况时SNDR≈SNR，大概就是这么个关系。 6. ENOBENOB真实的反映了我们ADC的有效位数是多少，让我们可以真正了解这个ADC的真实性能。 7. ADC的输入阻抗一般在我们使用ADC时，尤其是MCU内部自带的ADC，都会说明一下对外面信号源阻抗的要求，如注明我们的ADC对外面的输入阻抗要求是10K。 这项参数意味着我们的被测信号源的内阻不能大于10K，否则我们的输出精度将无法被保证。原因是芯片内部的ADC电路前面有一个采样保持电路，假如外面内阻太大会直接影响到这个电路的充放电，从而影响到我们最终的转换精度。 8. ADC的转换时间以SAR ADC为例，一般MCU内部自带的ADC可有有几个配置可以影响到ADC的转换速度：转换位数N，ADC时钟f，采样保持时间t。那么我们的ADC转换一次的时间就是N*1/f+t，这就是我们ADC转换一次的时间。 我们会发现有的MCU可以选择10bit或者12bit输出模式，有的人会想这是不是多此一举，实际上从上面的公式可以看出，我们的转换位数会影响到我们ADC的转换速度的。 另外说一句，对于同一个ADC，假如我们的转换速度设置很快也会降低我们的ADC精度，因此你会发现所有ADC 的Datasheet中的转换精度描述一栏的测试条件栏中会加上对转换速度的限制条件。所以，我们在使用ADC时，若没有速度的要求，建议将ADC的转换速度适当降低，以换取较为准确的精度。 9. 参考资料 谈谈ADC的相关性能参数(一) ADC的INL和DNL 对ADC（DAC）的线性度（INL和DNL）的一点理解 ADC参数解释和关键指标 ADC增益误差Gain Error及校准Calibration详解 ADC的offset是什么意思？ 关于输入阻抗和输出阻抗的理解]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——内存策略（4）]]></title>
    <url>%2F2019%2F10%2F16%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内存策略是每个协议栈的基石之一，所谓百尺高楼平地起，看看nimble的钢筋混凝土有没黑科技。 前言理解不对的地方欢迎斧正。 nimble的内存管理主要由以下文件组合实现:queue.h、os_mempool.c、os_mempool.h、os_mbuf.c、os_mbuf.h、mem.c、mem.h。 目录 1. queue.h 1.1. 双向链表 1.2. 双向链表的需求 1.3. 双向链表的实现 1.3.1. FreeBSD的TAILQ 1.3.2. linux的LIST 2. os_mempool.c &amp; os_mempool.h 3. os_mbuf.c &amp; os_mbuf.h 4. mem.c &amp; mem.h 5. 总结 6. 参考资料 1. queue.h91年的伯克利队列，产自FreeBSD，上等轮子，收藏学习之。 头文件包含5种队列的实现，而nimble用到三种，分别是TAILQ、SLIST、STAILQ。 因为涉及经典的双向链表实现，所以有去翻资料专门学习，分享一下双向链表学习心得。 1.1. 双向链表形如下图，元素之间可以双向追溯的链状结构，可称双向链表。 C编程常会自定义结构体，当希望将结构体串成如上图样式时，传统做法是把结构体嵌入链表元素中，下面介绍的是另外一种方式，将链表元素嵌入自定义结构体中，这时自定义结构体称为“宿主结构体”。 1.2. 双向链表的需求 可将链表元素放进任意宿主结构体中 方便用户访问宿主结构体中的成员 支持链表基本操作（获取第一个链表元素、获取最后一个链表元素、插入元素、移除元素等） 1.3. 双向链表的实现分享两种应用得比较广泛的双向链表实现，源码分析请到参考资料章节，这里简单归纳总结。 1.3.1. FreeBSD的TAILQ 访问宿主结构体方式：指针间接访问，无须计算过程 二级指针： 因为next是宿主结构体的一级指针，而prev指向next，所以prev就是宿主结构的二级指针。 若prev为宿主结构体的一级指针，则在删除/添加element的时候，需要判断是否为第一个element，如果是则要将element的prev设置为NULL。 1.3.2. linux的LIST 访问宿主结构体方式：每次访问都需计算container_of 一级指针：代码清晰易懂 2. os_mempool.c &amp; os_mempool.h 依赖关系： 用queue.h中的宏定义串链表 主要实现概念： 一个mempool_head下挂着一条mempool链表 每个mempool的memblock_head下挂着一条memblock链表 每个mempool的info表明memblock链表的信息（block个数、block大小等） 主要实现功能： os_mempool_init：往mempool链表插入一个新的mempool os_memblock_get：从mempool中获得一个block os_memblock_put：将block放回mempool中 3. os_mbuf.c &amp; os_mbuf.h 依赖关系： 用queue.h中的宏定义串链接 用mempool.h中的mempoo对象 主要实现概念： 一个mbuf_pool_head下挂着一条mbuf_pool链表 每个mbuf_pool包含一个mempool 将memblock强制转化成mbuf+databuf 主要实现功能： os_mbuf_get：获得一个mbuf（databuf不包含pkthdr） os_mbuf_get_pkthdr：获得一个mbuf（databuf包含pkthdr） os_mbuf_free：释放一个mbuf os_mbuf_append：往mbuf的databuf中添加用户数据，如果当前mbuf不够用，则申请一个新的mbuf添加，直到申请失败或者数据添加完成。 os_mbuf_off：自指定mbuf的databuf中获得指定offset的地址，如果当前mbuf的databuf没有足够offset，则继续从next mbuf获得，直到next_mbuf = NULL为止。 os_mbuf_adj：裁剪mbuf的databuf，比如当前databuf有10个字节数据，需要从头裁剪12个数据，则会将当前databuf长度等于0，并且将下一个mbuf的databuf长度减2。 os_mbuf_prepend：向前扩展指定大小的databuf内存空间，返回扩展后地址，如果leading space不够，则申请一个新的mbuf，将当前mbuf挂在新的mbuf后面。 os_mbuf_extend：向后扩展指定大小的databuf内存空间，返回扩展后地址，如果trailing space不够，则申请一个新的mbuf，挂在mbuf当前mbuf后面。 os_mbuf_pullup：从mbuf中获取能提供指定大小连续有效用户数据的mbuf。 如果当前mbuf足够多有效用户数据，则返回当前mbuf 如果当前mbuf无足够有效用户数据，但存在下一个mbuf，则将下一个mbuf有效用户数据拷贝到当前mbuf有效用户数据后面，然后返回当前mbuf。 如果当前mbuf无足够有效用户数据，也不存在下一个mbuf，则申请一个mbuf，将当前mbuf的用户数据拷贝到申请到的mbuf，然后返回申请的mbuf。 os_mbuf_trim_front：将指定mbuf链表的前面所有空mbuf移除掉。 4. mem.c &amp; mem.h主要实现功能： mem_malloc_mempool_gen：调用malloc获得内存，用于构造上述章节的数据结构。 mem_split_frag：从mbuf中fragment出一包数据。 5. 总结 queue：提供链表实现，用于构造内存池 mempool：提供基础内存池的API，从内存池中获取/释放内存块 mbuf：提供负责内存块的API，根据实际要求修改内存块（增加帧头帧尾、添加数据等） mem：提供nimble中最高抽象的内存初始化 6. 参考资料 TAILQ 队列之一二事 libevent 学习———-尾队列 tail queue Libevent源码分析—–TAILQ_QUEUE队列 freebsd内核代码中queue和list结构初探 Linux内核中经典链表 list_head 常见使用方法解析 浅析长度为0的数组]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈BLE核心架构和数据帧]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%B5%85%E8%B0%88BLE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[谈谈大家平常少接触的蓝牙核心规范中关于ble有趣的部分，点到即止。 前言蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。 目录 1. ble核心规范简介 1.1. ble核心系统架构 1.1.1. host 1.1.2. controller 1.1.3. hci 1.2. ble传输载体 1.2.1. le link layer到LE-C的signaling数据帧 1.2.2. le link layer到ADVB-C的signaling数据帧 1.2.3. l2cap manager的signaling数据帧 1.2.4. 更高层协议的signaling数据帧 1.2.5. 可靠的异步用户数据帧 1.2.6. 不可靠的异步用户数据 1.2.7. 举例 1. ble核心规范简介下面从两个角度来总览ble协议，一个是从协议层级划分角度，即下文ble核心系统架构章节，另一个是协议数据流向角度，即下文ble传输载体章节。 NOTE：运输载体英文原文是traffic bearers，有种小船之于水流的感觉，我不知道如何翻译才贴切，欢迎各位提建议。 1.1. ble核心系统架构下图为ble核心系统架构（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），ble核心架构可划分为两部分，分别是host和controller。 1.1.1. host gatt att gap smp l2cap 1.1.2. controller device manager link manager baseband resource manager link controller phy 1.1.3. hcihost和controller可通过hci（host-controller-interface）接口互相通信。具体表现为： host通过hci向controller发送command controller通过hci向host发送event host和controller通过hci互传acl data 1.2. ble传输载体下图为ble传输载体示意图（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），左边Application表示host中除l2cap以外部分的集合，Bluetootch core表示l2cap和整个controller。 结合上图，ble协议中流动的所有数据帧如下，即使分包也是由以下部分帧拆分而来： 1.2.1. le link layer到LE-C的signaling数据帧 如ll control pdu的LL_FEATURE_REQ 1.2.2. le link layer到ADVB-C的signaling数据帧 如scanning pdu的SCAN_REQ 如initiating pdu的CONNECT_IND 1.2.3. l2cap manager的signaling数据帧 如l2cap的connection parameter update request 1.2.4. 更高层协议的signaling数据帧 如smp的pairing request 1.2.5. 可靠的异步用户数据帧 如gatt的write without response，其中att_payload包含用户数据 1.2.6. 不可靠的异步用户数据 如advertising的ADV_IND，其中adv_payload包含ad type格式的用户数据 1.2.7. 举例针对上述帧举一个例子详细说明，目的是理清关系。 例子中有两个角色，一个是嵌入式蓝牙设备，称为device，另一个是手机，称为app。 如图所示从左到右为角色的每一层，从上到下为时间线。图中的交互行为并不完整，如：缺少响应包，但是这不影响我们的阅读。 双方处于未连接状态 某个时刻device’s gap通过hci发送command，让device’s controller开始发送ADV_IND，即开始广播，其中ADV_IND中包含device的设备名。 某个时刻app’s gap通过hci发送command，让app’s controller开始发送SCAN_REQ，即开始扫描周边蓝牙设备。 app’s controller发现了正在广播的device，随后通知app’s gap，紧接着app’s gap通过hci发送command，让app’s controller开始发送CONNECT_IND，即发起连接请求 双方刚刚建立连接状态 app’s controller向device ‘s controller发送LL_FEATURE_REQ，希望知道刚刚连上的device支持哪些特性。 双方已经连接了一段时间状态 连接一段时间后，device觉得频繁与app通信影响功耗，所以device’s l2cap manager将connection parameter update request封装成acl data，通过hci发送给device’s controller，device’s controller随即将数据发给app’s l2cap manager，即连接参数更新请求，该请求要求加大连接间隔。 某个时刻app向发送用户数据给device，app’s gatt将write without response发送给l2cap，l2cap将write without response封装成acl data通过hci发送给app’s controller，让app’s controller开始发送write without respon给device’s gatt。 某个时刻app觉得传输明文用户数据太危险，即app’s smp发起了pairing request给l2cap，l2cap将pairing request封装成acl data通过hci发送给app’s controller，让app’s controller开始发送pairing request给device’s smp。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——移植nimble（3）]]></title>
    <url>%2F2019%2F10%2F09%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%A7%BB%E6%A4%8Dnimble%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[站在巨人的肩膀上可以看的更远。 前言移植目标：手机app可以搜索到ble广播，能成功连接并发现服务。 目录 1. 土方法 2. 移植host 2.1. 添加nimble 2.2. 添加空白SConscript 2.3. 移植阶段一 2.3.1. 无法打开头文件 2.3.2. 无法打开头文件（缺少头文件） 2.3.3. 无法打开头文件（存在多个同名头文件） 2.3.4. 缺少标识符定义 2.4. 移植阶段二 2.4.1. 缺少endian.c中实现的函数 2.4.2. 缺少mem.c中实现的函数 2.4.3. 缺少os_mbuf.c实现的函数 2.4.4. 缺少os_mempool.c实现的函数 2.4.5. 缺少nimble_port.c实现的函数 2.4.6. 缺少os_msys_init.c实现的函数 2.4.7. 缺少tinycrypt加密组件 2.5. 移植阶段三 2.5.1. 存在多个ble_hc_trans_xxxx同名函数 2.5.2. 缺少ble_npl_xxx函数定义 2.6. 移植host总结 3. 移植controller 3.1. 移植阶段一 3.1.1. 无法打开头文件 3.2. 移植阶段二 3.2.1. 无法打开头文件（存在多个同名头文件） 3.2.2. 缺少标识符定义 3.2.3. 无法识别内联汇编 3.2.4. 缺少ble_hw.c中实现的函数 3.2.5. 缺少os_cputime.c中实现的函数 3.2.6. 缺少os_cputime_pwr2.c中实现的函数 3.2.7. 缺少hal_timer.c中实现的函数 3.2.8. 缺少ble_npl_hw_set_isr函数定义 3.2.9. 缺少ble_npl_hw_is_in_critical函数定义 3.3. 移植controller总结 4. 移植profile 4.1. 添加心率profile 4.2. 移植proifile总结 5. 启动运行 5.1. 缺少标识符定义 5.2. 修复bug 5.3. 添加调试 5.4. 编译烧录 6. 总结 1. 土方法第一个问题，nimble的porting目录看不懂，钻牛角尖要不得，故跑到大佬的github上寻求解决方案。 然后有了第一个解决思路：基于可以正常运行的工程，将部分nimble源文件从SConscript脚本中移除。 然后第二个问题来了，移除哪些源文件？ 按照笔者对nimble官方文档的了解，nimble支持host和controller解耦，那么第一步移植工作就先保留host代码，将controller部分全部移除掉。 2. 移植host2.1. 添加nimble将官网下载的nimble压缩包解压，并将生成的文件夹复制粘贴到myboard目录下，即rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0。 2.2. 添加空白SConscript添加SConscript文件到nimble目录下，即rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\SConscript。 2.3. 移植阶段一把所有rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\nimble\host里面除了mesh文件夹和test文件夹以外的.c文件加进刚创建的空白SConscript脚本。 NOTE：ble mesh后面再挖坑，这里先不展开。 按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。 2.3.1. 无法打开头文件1error: #5: cannot open source input file &quot;sysinit/sysinit.h&quot;: No such file or directory 错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/porting/nimble/include&#39;，同类报错可用同样方法解决。 2.3.2. 无法打开头文件（缺少头文件）1error: #5: cannot open source input file &quot;base64/base64.h&quot;: No such file or directory 错误原因：nimble包没有该文件解决办法：从mynewt的encoding目录下，拷贝base64到rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\ext\，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/ext/base64/include&#39;。 2.3.3. 无法打开头文件（存在多个同名头文件）1error: #5: cannot open source input file &quot;nimble/nimble_npl_os.h&quot;: No such file or directory 错误原因：nimble包有多个该文件，只是没有将头文件目录添加进编译脚本解决方法：该文件定义了os的抽象接口，协议栈会调用这些接口，这些接口的实现每个os都不一样，我们这里参考rt-thread官方做法，直接下载该文件夹到rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl下，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/porting/npl/rtthread/include&#39;。 2.3.4. 缺少标识符定义1error: #20: identifier &quot;MYNEWT_VAL_BLEUART_MAX_INPUT&quot; is undefined 错误原因：缺少宏定义解决方法：将nimble/host/services/bleuart/src/bleuart.c从SConscript脚本中删除，暂不考虑实现该profile。 1error: #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined 错误原因：缺少宏定义解决方法：将nimble/host/services/dis/src/ble_svc_dis.c从SConscript脚本中删除，暂不考虑实现该profile。 2.4. 移植阶段二经过上节处理之后，编译均是以下错误： 1Error: L6218E: Undefined symbol xxxx (referred from xxxx). host文件夹内的代码会引用其他目录下的公共组件以及公共函数。组件如：内存池，函数如：大小端转换函数。 所以该阶段目标是将host文件夹依赖的公共组件和公共函数补充完整。 2.4.1. 缺少endian.c中实现的函数解决方法：将porting/nimble/src/endian.c添加进SConscript脚本。 2.4.2. 缺少mem.c中实现的函数解决方法：将porting/nimble/src/mem.c添加进SConscript脚本。 2.4.3. 缺少os_mbuf.c实现的函数解决方法：将porting/nimble/src/os_mbuf.c添加进SConscript脚本。 2.4.4. 缺少os_mempool.c实现的函数解决方法：将porting/nimble/src/os_mempool.c添加进SConscript脚本。 2.4.5. 缺少nimble_port.c实现的函数解决方法：将porting/nimble/src/nimble_port.c添加进SConscript脚本。 2.4.6. 缺少os_msys_init.c实现的函数解决方法：将porting/nimble/src/os_msys_init.c添加进SConscript脚本。 2.4.7. 缺少tinycrypt加密组件解决方法：添加以下路径到SConscript文件。ext/tinycrypt/src/aes_decrypt.cext/tinycrypt/src/aes_encrypt.cext/tinycrypt/src/utils.c 2.5. 移植阶段三经过上节处理之后，编译剩下以下错误： 121. Error: L6218E: Undefined symbol ble_hci_trans_xxxx (referred from xxxx).2. Error: L6218E: Undefined symbol ble_npl_xxx (referred from xxxx). 前面做的移植操作，哪个平台都是一样的。而对于这两类错误，不同的应用场景和平台，解决方案会有所差异。 2.5.1. 存在多个ble_hc_trans_xxxx同名函数全局搜索nimble包会发现这些函数在多个.c文件中都有实现，位置如下： 123456789101112131415161718apache-mynewt-nimble-1.2.0└──nimble └──transport ├──da1469x │ └──src │ └──da1469x_ble_hci.c ├──emspi │ └──src │ └──ble_hci_emspi.c ├──ram │ └──src │ └──ble_hci_ram.c ├──socket │ └──src │ └──ble_hci_socket.c └──uart └──src └──ble_hci_uart.c 这意味着我们需要做出选择，为这些函数接口选择具体实现。这时候引入新问题，“我们在选择什么”。 参考这篇blog，可知： host和controller可通过hci（host-controller-interface）接口互相通信。具体表现为： host通过hci向controller发送command controller通过hci向host发送event host和controller通过hci互传acl data 而编译报错缺失的ble_hc_trans_xxxx函数为： ble_hci_trans_reset ble_hci_trans_cfg_hs（该API注册接收evt和acl data的回调函数） ble_hci_trans_buf_alloc ble_hci_trans_buf_free ble_hci_trans_hs_cmd_tx ble_hci_trans_hs_acl_tx 也就是我们在选择用什么样的transport来实现hci功能，即： 如果我们需要在一颗芯片上运行host+controller，那么就要选ble_hci_ram.c文件，即host和controller之间用ram通信。 如果我们需要在一颗芯片上运行host，另一颗芯片运行controller，那么就可以选ble_hci_uart.c文件，即host和controller之间用uart通信。 NOTE：市场上一些简单的智能设备，如手环、心率带、无线传感器，都会选择在一颗芯片上运行完整的协议栈，即host+controller，无论在成本还是开发上都会简单很多。但是一些比较复杂如多协议网关、机顶盒的产品，则需要一个强大的cpu跑linux，并用linux实现host（bluez、bluedroid），然后外挂一颗性能和成本较低的蓝牙芯片跑controller。 这里我们选择ble_hci_ram.c文件，将nimble/transport/ram/src/ble_hci_ram.c和cwd + &#39;/nimble/transport/ram/include&#39;加进SConscript。 2.5.2. 缺少ble_npl_xxx函数定义npl全称为nimble porting layer，顾名思义，这些函数是协议栈需要调用的接口，协议栈不会实现这部分内容，需要我们自己去实现，协议栈用到的所有接口在nimble_npl.h中。 这部分nimble没有注释说明接口该如何实现，移植者只能参考其他os的实现以及nimble协议栈调用接口代码，去猜这个函数做了什么，我不喜欢这一点。 这里我们将rt-thread官方已经移植好的代码加进SConscript，即porting/npl/rtthread/src/npl_os_rtthread.c。 NOTE：需要注释掉npl_os_rtthread.c里面的ble_npl_task_init函数。 2.6. 移植host总结总的来说，nimble中移植host功能需要关注以下几种类型代码。 host协议核心代码 公用组件和公用函数 hci transport os特定代码 myboard文件夹下载地址 3. 移植controller3.1. 移植阶段一把所有rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\nimble\controller里面除了test文件夹以外的.c文件加进之前的SConscript脚本。 按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。 3.1.1. 无法打开头文件1error: #5: cannot open source input file &quot;controller/ble_ll.h&quot;: No such file or directory 错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/nimble/controller/include&#39;，同类报错可用同样方法解决。 3.2. 移植阶段二前面做的移植操作，无论哪个平台都是一样的。而接下来的操作，不同的应用场景和平台，解决方案会有所差异。 3.2.1. 无法打开头文件（存在多个同名头文件）1error: #5: cannot open source input file &quot;ble/xcvr.h&quot;: No such file or directory xcvr英文原名为transceiver，即既有包含发射器，又有接收器的radio设备。 xcvr正常运行前需要有一段rampup时间 xcvr在发射器和接收器之间切换，需要软件执行时间 因为不同设备，这两个参数会有比较大差异，而ble对于时间的要求又是us级别的，所以需要移植者根据自己的硬件设备来实现。 这里我们选择nrf52的xcvr文件，将nimble/drivers/nrf52/src/ble_phy.c和cwd + &#39;/nimble/drivers/nrf52/include&#39;加进SConscript。 3.2.2. 缺少标识符定义1error: #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined 协议栈要正常运行必须有一些默认参数，否则编译不通过，如：射频发射功率、支持最大连接数等，参数以及参数的说明可以从目录对应的syscfg.yml文件获知。 由于我们不使用rt-thread提供的软件包功能，所以将用该文件替换如下路径同名文件：rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl\rtthread\include\config\config.h。 同时在rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\nimble\include\syscfg\syscfg.h文件开头位置中include该头文件： 123456789101112#ifndef H_MYNEWT_SYSCFG_#define H_MYNEWT_SYSCFG_...#define MYNEWT_VAL(x) MYNEWT_VAL_ ## x#include "config/config.h"...#endif NOTE：因为通过宏定义配置参数的文件都会include &lt;syscfg/syscfg.h&gt;文件，将include “config/config.h”放在该文件前可以起到全局配置的作用。 3.2.3. 无法识别内联汇编1error: #18: expected a &quot;)&quot; 用c来实现内联汇编的功能，用该文件替换如下路径同名文件，即：rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\nimble\drivers\nrf52\src\ble_phy.c。 3.2.4. 缺少ble_hw.c中实现的函数解决方法：将nimble/drivers/nrf52/src/ble_hw.c添加进SConscript脚本。 3.2.5. 缺少os_cputime.c中实现的函数解决方法：将porting/nimble/src/os_cputime.c添加进SConscript脚本。 3.2.6. 缺少os_cputime_pwr2.c中实现的函数解决方法：将porting/nimble/src/os_cputime_pwr2.c添加进SConscript脚本。 3.2.7. 缺少hal_timer.c中实现的函数解决方法：将porting/nimble/src/hal_timer.c添加进SConscript脚本。 3.2.8. 缺少ble_npl_hw_set_isr函数定义1Error: L6218E: Undefined symbol ble_npl_hw_set_isr (referred from ble_phy.o). 该接口用于设置中断号以及对应的中断服务函数。 这里我们将porting/npl/rtthread/src/nrf5x_isr.c添加进SConscript脚本。 3.2.9. 缺少ble_npl_hw_is_in_critical函数定义在rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl\rtthread\src\npl_os_rtthread.c中修改如下实现： 1234567891011121314151617181920volatile int ble_npl_in_critical = 0;uint32_t ble_npl_hw_enter_critical(void)&#123; ++ble_npl_in_critical; return rt_hw_interrupt_disable();&#125;void ble_npl_hw_exit_critical(uint32_t ctx)&#123; --ble_npl_in_critical; rt_hw_interrupt_enable(ctx);&#125;bool ble_npl_hw_is_in_critical()&#123; return (ble_npl_in_critical &gt; 0);&#125; 3.3. 移植controller总结总的来说，nimble中移植controller功能需要关注以下几种类型代码。 controller协议核心代码 硬件平台差异文件（ble_phy.c/ble_hw.c/nrf5x_isr.c） 公用组件和公用函数(hal_timer.c/…) 应用宏定义配置文件（config.h/syscfg.yml） myboard文件夹下载地址 4. 移植profile不同的应用场景对于蓝牙核心协议栈（host+controller）的用法不一样，为了规范化和互联互通，针对某些应用场景，会有一套蓝牙核心协议栈的操作指南，这份指南称为profile。 4.1. 添加心率profile下载rt-thread官方推荐的应用代码，添加进rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\apps\blehr\src\文件夹。 将apps/blehr/src/gatt_svr.c添加进SConscript脚本。 将apps/blehr/src/blehr.c添加进SConscript脚本。 将cwd + &#39;/apps/blehr/src&#39;添加进SConscript脚本。 4.2. 移植proifile总结添加profile的过程比较杂乱，但这没办法，因为profile和os、nimble的启动方式等等都有耦合，特别是rtthread这里启动nimble的方式有点绕。 5. 启动运行经过上节处理之后，编译报以下错误： 1Error: L6218E: Undefined symbol ble_hs_thread_startup (referred from blehr.o). 解决方法：将porting/npl/rtthread/src/nimble_port_rtthread.c添加进SConscript脚本。 通过阅读nimble_port_rttherad.c文件得知，如果需要支持controller，还需要先增加宏定义NIMBLE_CFG_CONTROLLER=1，所以将该宏定义添加进SConscript脚本。 5.1. 缺少标识符定义1234567error: #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE&quot; is undefinederror: #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY&quot; is undefinederror: #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE&quot; is undefinederror: #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY&quot; is undefined 在porting/npl/rtthread/include/config/config.h文件添加以下内容： 1234567891011121314151617//thread config#ifndef MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE#define MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE (2048)#endif#ifndef MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY#define MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY (5)#endif#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE#define MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE (2048)#endif#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY#define MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY (4) // must higher than MYNEWT_VAL_BLE_HOST_TASK_PRIORITY, numerically smaller#endif 5.2. 修复bug将rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\nimble\include\os\endian.h文件1#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ 改为： 1#if defined (__BYTE_ORDER__) &amp;&amp; (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) 5.3. 添加调试将porting/npl/rtthread/src/modlog.c添加进SConscript脚本。 用该文件替换rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl\rtthread\src\modlog.c。 用该文件替换rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\nimble\include\modlog\modlog.h。 5.4. 编译烧录myboard文件夹下载地址 生成工程、编译、烧录后，在串口调试助手输入ble_hr，设备开始广播。 6. 总结通过这一章节的学习，对于nimble的目录结构、参数配置方式，有更深刻的认识。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——移植bsp（2）]]></title>
    <url>%2F2019%2F10%2F09%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%A7%BB%E6%A4%8Dbsp%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[为你的bsp建立一个干净的项目框架。 前言博主不喜欢从零开始造轮子，但是有“不试一下鬼知道做了什么”强迫症，因此钟爱搬运移植文件，用一些土方法来理清软件之间的关系以及换一个平台怎么办的思路。 移植目标：移植rt-thread到开发板上，并通过串口打印hello world。 目录 1. 建立项目框架 1.1. 认识nrfx 1.2. rt-thread构建环境 1.2.1. 创建bsp文件夹 1.2.2. 添加bsp的模板工程 1.2.3. 添加bsp的Kconfig 1.2.4. 添加bsp的rtconfig.py 1.2.5. 添加bsp的SConscript/SConstruct 1.2.6. 添加nrfx 1.2.7. 添加设备驱动实现 1.2.8. 添加应用层代码 1.3. 验证环境构建结果 1. 建立项目框架1.1. 认识nrfx文件夹路径：nRF5_SDK_15.3.0_59ac345\modules\nrfx nrfx由nordic提供的一系列外设驱动组成，无需集成厚重的标准SDK就能把芯片跑起来，是一个轻量级的驱动库。 移植只需要关注以下内容： 芯片类型宏定义 nrfx_config.h nrfx_glue.h nrfx_log.h CMSIS/include 芯片类型宏定义：在编译阶段必须加入一款芯片类型宏定义，否则编译会报错，后面会在SConscript中加入芯片类型宏定义。 12345678910111213141516171819202122232425262728293031323334/* Device selection for device includes. */#if defined (NRF51) #include "nrf51.h" #include "nrf51_bitfields.h" #include "nrf51_deprecated.h"#elif defined (NRF52810_XXAA) #include "nrf52810.h" #include "nrf52810_bitfields.h" #include "nrf51_to_nrf52810.h" #include "nrf52_to_nrf52810.h"#elif defined (NRF52811_XXAA) #include "nrf52811.h" #include "nrf52811_bitfields.h" #include "nrf51_to_nrf52810.h" #include "nrf52_to_nrf52810.h" #include "nrf52810_to_nrf52811.h" #elif defined (NRF52832_XXAA) || defined (NRF52832_XXAB) #include "nrf52.h" #include "nrf52_bitfields.h" #include "nrf51_to_nrf52.h" #include "nrf52_name_change.h"#elif defined (NRF52840_XXAA) #include "nrf52840.h" #include "nrf52840_bitfields.h" #include "nrf51_to_nrf52840.h" #include "nrf52_to_nrf52840.h" #elif defined (NRF9160_XXAA) #include "nrf9160.h" #include "nrf9160_bitfields.h" #else #error "Device must be defined. See nrf.h."#endif /* NRF51, NRF52810_XXAA, NRF52811_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52840_XXAA, NRF9160_XXAA */ nrfx_config.h:该文件可以配置nrfx驱动，可以在keil在界面配置，如下图所示。 nrfx_glue.h该文件由未实现的宏定义组成，未实现宏定义可以看成钩子函数，nrfx驱动代码会调用这些钩子函数，如果需要用到该钩子函数，则实现，若不需要则留空。 如需要用到临界区，防止嵌套中断发生，nrfx_glue.h文件如下： 123456789/** * @brief Macro for entering into a critical section. */#define NRFX_CRITICAL_SECTION_ENTER() &#123;unsigned int ctx; ctx = nrfx_enter_critical();/** * @brief Macro for exiting from a critical section. */#define NRFX_CRITICAL_SECTION_EXIT() nrfx_exit_critical(ctx);&#125; 如不需要用到临界区，不考虑嵌套中断发生的情况，nrfx_glue.h文件如下： 123456789/** * @brief Macro for entering into a critical section. */#define NRFX_CRITICAL_SECTION_ENTER() /** * @brief Macro for exiting from a critical section. */#define NRFX_CRITICAL_SECTION_EXIT() nrfx_log.h同上 CMSIS/include 根据nrfx根目录README提示，可用doxygen生成文档，生成的文档中有下图红框要求。直接下载该文件夹即可，不需要修改。 1.2. rt-thread构建环境了解nrfx后，接下来就要将其与rt-thread的构建环境关联起来。 1.2.1. 创建bsp文件夹在bsp目录下创建文件夹myboard，即rt-thread\bsp\myboard。 1.2.2. 添加bsp的模板工程 rt-thread官方NOTE：要生成 MDK 或者 IAR 的工程文件，前提条件是 BSP 目录存在一个工程模版文件，然后 scons 才会根据这份模版文件加入相关的源码，头文件搜索路径，编译参数，链接参数等。而至于这个工程是针对哪颗芯片的，则直接由这份工程模版文件指定。所以大多数情况下，这个模版文件是一份空的工程文件，用于辅助 SCons 生成 project.uvprojx 或者 project.eww。 在调用scons --target=mdk5前，需在rt-thread\bsp\myboard先提供一个mdk模板工程： 下面简单演示模板工程创建过程。 1.2.3. 添加bsp的Kconfig将rt-thread\bsp\stm32f10x\Kconfig搬运到myboard目录下，删除Kconfig文件中不需要部分。 12345config SOC_STM32F1boolselect ARCH_ARM_CORTEX_M3default ysource &quot;$BSP_DIR/drivers/Kconfig&quot; 若在myboard目录下执行menuconfig，则menuconfig会根据rt-thread\bsp\myboard\Kconfig中的语句生成rt-thread\bsp\myboard\rtconfig.h，该头文件包含各种宏定义。 rt-thread\bsp\myboard\Kconfig文件可通过source语句引用其他目录下的Kconfig文件，协助其生成所需的宏定义，如以下例子： Kconfig文件的目录路径： 1234567rt-thread├──Kconfig # root Kconfig ├──src│ └──Kconfig # kernal src Kconfig└──bsp └──myboard └──Kconfig # bsp Kconfig rt-thread\bsp\myboard\Kconfig引用rt-thread\Kconfig语句： 123456config RTT_DIR string option env=&quot;RTT_ROOT&quot; default &quot;../..&quot;source &quot;$RTT_DIR/Kconfig&quot; rt-thread\Kconfig引用rt-thread\src\Kconfig语句： 1source &quot;$RTT_DIR/src/Kconfig&quot; rt-thread\src\Kconfig协助生成宏定义内容： 123456config RT_TICK_PER_SECOND int &quot;Tick frequency, Hz&quot; range 10 1000 default 100 help System&apos;s tick frequency, Hz. 在myboard目录下执行menuconfig配置后，会在rt-thread\bsp\myboard\rtconfig.h生成如下宏定义： 123456#ifndef RT_CONFIG_H__#define RT_CONFIG_H__#define RT_TICK_PER_SECOND 100#endif 最后其他.c文件可引用该头文件，并使用RT_TICK_PER_SECOND宏定义。实现在rt-thread\bsp\myboard用menuconfig就可以配置整个工程的静态设置，如： 1234567#include &lt;rtconfig.h&gt;void SystemClock_Config(void)&#123; SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND); NVIC_SetPriority(SysTick_IRQn, 0);&#125; 1.2.4. 添加bsp的rtconfig.py将rt-thread\bsp\nrf52832\rtconfig.py搬运到myboard目录下。 当调用sconsc --target=mdk5生成mdk工程时候，脚本会根据rt-thread\bsp\myboard\rtconfig.py文件中的变量CPU=&#39;cortex-m4&#39;选择对应的文件添加进工程，如下图针对性添加了m4内核的上下文切换文件。 1.2.5. 添加bsp的SConscript/SConstruct将rt-thread\bsp\nrf52832\SConscript和rt-thread\bsp\nrf52832\SConstruct搬运到myboard目录下。 删除SConscript文件中不需要部分。 1objs = objs + SConscript(os.path.join(cwd, &apos;nRF5_SDK_13.0.0_04a0bfd/components/SConscript&apos;)) 1.2.6. 添加nrfx参考官方的做法创建一个nordic文件夹，并在myboard\nordic目录下添加以下内容： CMSIS/include文件夹 nrfx文件夹 SConscript文件 1.2.7. 添加设备驱动实现参考官方的做法创建一个drivers文件夹，并在myboard\drivers目录下添加以下内容： board.c和board.h drv_gpio.c和drv_gpio.h drv_uart.c和drv_uart.h SConscript文件 1.2.8. 添加应用层代码参考官方的做法创建一个applications文件夹，并在myboard\applications目录下添加以下内容： application.c SConscript文件 其中application.c文件的main函数中包含打印hello world的代码，至于是如何从上电运行到main函数的，可参考启动流程。 1.3. 验证环境构建结果myboard文件夹下载地址 至此，最简洁的功能移植已经完成，后面验证是否移植成功，若成功串口助手将打印hello world。 进入rt-thread\bsp\myboard路径下，右键打开env。 用usb线将板子与PC连接 验证menuconfig功能，同时配置console名字 验证scons –target=mdk5 编译，烧录，观察串口打印信息 NOTE：rt_kprintf依赖rt_console_set_device函数1、若用rt_kprintf函数打印信息，则需要一个标记为console设备的通信接口设备。2、rt_console_set_device(console_name)函数从众多已注册通信接口设备中找到与参数console_name相同名字的设备，并将该设备标记为console设备。3、rt_hw_serial_register(uart0)函数注册一个名字为uart0的通信接口设备。所以生成mdk工程前，需要用menuconfig配置console_name为uart0，否则rt_kprintf就会由于找不到通信接口设备，导致无法打印信息。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——预备知识（1）]]></title>
    <url>%2F2019%2F09%2F25%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[磨刀不误砍柴工，前期多做点理论积累，后期才能少掉坑。 前言rt-thread简介 nimble简介 目录 1. 导读 2. 系统 3. 蓝牙 4. 硬件 5. 软件 1. 导读知识点根据需要认知的程度分为：了解、理解、专业，对于知识点不建议强行记忆，建议多看、多想和多做，所谓读书百遍其意自现。 例子 程度 备注 信号量 了解 两个函数之间的共享变量，像全局变量标志位 理解 工作机制、API使用方法，无须深究源码 专业 略 一般从网上搜一篇文章就可以达到了解的程度，理解则需要多看几篇。 刚接触一个复杂的软件的时候，不建议深究源码，我个人的习惯是按照： 软件可以运行 理解裁剪 软件刚刚好可以运行 研究细节 就是想说学习方法很重要，不要钻牛角尖。 2. 系统关于rt-thread的入门资料，rt-thread文档中心这部分做的很cool，其中“内核”、“Env工具”、“设备和驱动”、“代码贡献-软件包开发”章节，建议至少看一遍。 知识点1（理解）：内核整个章节 知识点2（了解）：env的安装（只是为了运行scons和menuconfig） 知识点3（了解）：menuconfig的使用 Kconfig（该文件决定rt_config.h包含哪些宏定义，rt_config.h会被nimble协议栈include） 知识点4（了解）：scons的使用 scons --target=mdk5（keil编译和仿真） SConscript（修改该脚本，配合scons --target=mdk5来理解协议栈） 知识点5（理解）：设备和驱动 移植芯片驱动（尽量理解，后面移植章节介绍） 知识点6（了解）：软件包 Kconfig文件 这里除了知识点3和知识点5，其他知识点rt-thread官网已提供足够资料学习。 3. 蓝牙蓝牙核心规范下载地址 蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。 不同厂家根据自家芯片的特性，用代码去实现这份文档的内容，这些代码称为蓝牙协议栈。 基于蓝牙协议栈二次开发的工作，称为蓝牙应用开发。 学习蓝牙软件门槛不高，但是会有瓶颈： 它不难理解，不像人工智能需要有数学底蕴；它只是稍微复杂一点，花时间都能看懂，所以说门槛不高。 因为协议栈不开源，看不到底层实现，所以会遇到瓶颈。 nimble低功耗蓝牙协议栈，层层划分清晰，便于我们理解复杂的实现，而全开源解决了学习蓝牙软件的瓶颈问题，是学习蓝牙规范的一个好工具。 但要是商用就要斟酌一番，毕竟开源不收钱，出现bug只能自力更生。 知识点1：（理解）学习蓝牙软件不难，商用nimble需谨慎。 知识点2：（了解）蓝牙应用开发可通过博客/Q群/论坛等途径学习 推荐红旭论坛：http://bbs.wireless-tech.cn 4. 硬件只需要掌握一个硬件平台的知识点即可。 硬件：红旭 | HX-DK夏开发板 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO 知识点2（了解）：从官方资料了解串口TX和RX引脚编号、LED灯引脚编号以及外围电路 硬件：nordic | nrf52 dk开发板 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO 知识点2（了解）：从开发板背面了解串口TX和RX引脚编号、LED灯引脚编号及外围电路 5. 软件 rt-thread源码下载地址（后面文章使用v4.0.0版本） nimble源码下载地址（后面文章使用v1.2.0版本） mynewt源码下载地址 nrf52_sdk包下载地址（后面文章使用nRF5_SDK_15.3.0_59ac345版本） nrf的Device_Family_Pack下载地址（后面文章使用8.24.1版本） rt-thread官方移植nimble源码下载地址]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——题外话（0）]]></title>
    <url>%2F2019%2F09%2F25%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[- 前言这章与技术无关，是博主的一得之见，欢迎交流，求同存异。 目录 1. 为什么选rt-thread和nimble 1.1. 关于物联网 1.2. 关于rt-thread 1.3. 关于嵌入式软件 1.4. 关于ble协议栈 1.5. 关于时间投入 1. 为什么选rt-thread和nimble1.1. 关于物联网物联网的概念近几年开始重新翻炒起来，在5G技术的加持下，明眼人都能看出来这个万亿级市场钱途一片光明。 从现在各大厂在这一块布局来看，思路都是搭建从端到云的基础设施，开放平台接入，形成自己的生态圈，等到时机成熟再花式割韭菜，现在正处于一个攻城略地的白热化阶段。 大佬们在悄咪咪的抓住先机占领市场，建立生态。同样的，作为码农就应该有笨鸟先飞，抱紧大腿，学习新知识的觉悟。 依我愚见，各大厂的物联网操作系统（iot os）是一个不错的方向。 1.2. 关于rt-thread各家iot os技术指标，比如：上下文切换时间，快那么几个us等，对绝大部分应用场景来说，意义不大，所以这里不展开，趣度之。 我之所以选择rt-thread有以下考虑： C面向对象设计 集成nimble 上手门槛低 对国产老牌嵌入式os劲旅的支持 1.3. 关于嵌入式软件不少从事嵌入式行业的软件工作者，在上学期间没有接触过软件工程知识，博主就是之一。 工作一段时间后，写软件会有“套路章法”，有的来自公司祖传代码，有的是加班时一刹灵光，其中涉及的“道理”，问就是不知道，反正这样做就对了。 再到后来了解到：面向对象思想、SOLID设计原则、设计模式、uml等等，原来代码应该这样写，业务逻辑可以这样画出来。 嵌入式离不开底层，越是底层，代码设计越是精简，若是在精简中仍保持巧妙的设计思想，在我看来就是一份值得钻研的高质量代码。 rt-thread官方介绍系统采用C面向对象设计，这就很棒。在看了rtdef.h文件之后，很舒服，故决定拜读一下，要是能在其中领悟到一丝精髓也不错。 1.4. 关于ble协议栈市场上所有BLE芯片原厂都不会完全公开自己的协议栈，没有例外。如果想要研究完整协议栈（host + controller）的实现，要么到原厂去工作，要么目前就只能找全网仅有的以下两个开源协议栈。 zephyr 该项目有linux基金会背书，各大原厂形成社区一起维护，实力毋庸置疑。虽开发工具高效但学习成本高，不适合初学者，适合对开源项目有一定经验的人。 nimble 产自apache基金会（制订apache2 license的那个组织）。代码风格干净，与os耦合程度低，注释多，功能比zephyr少，适合学习。 1.5. 关于时间投入年轻人的时间是十分宝贵的。 我觉得年轻人不应该有“反正年轻，大把试错机会，先让子弹飞一会”的观念来麻痹自己，用战术上的勤奋来掩盖战略上的懒惰，选择比努力更重要。 研究协议栈已经算是术业专攻，如果不是工作刚需和兴趣，要注意时间投入回报问题。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coder Handbook]]></title>
    <url>%2F2019%2F08%2F17%2Fcoder-handbook%2F</url>
    <content type="text"><![CDATA[大佬有云： Talk is cheap. Show me the code. –Linus Torvalds 官方来说，代码好坏体现一个程序员的职业素养，在笔者看来代码是一个程序员的门面担当，在这个颜值即正义的时代，作为程序员如何码的一手好代码，是门必修课中的必修课。 前言 写该文档为目的是：形成一套平时监督自己代码是否合理的规范。 本文大部分的理论经验参考《Clean Code》——Robert C.Martin，如有理解不对，还请斧正。 最后，会附上笔者对于一些名词、动词对和形容词的理解。 目录 1. 命名 1.1. 代码简洁不代表模糊 1.2. 有意义的变量名 1.3. 避免使用编码或者前缀 1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词 2. 函数 2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。 2.2. 使用描述性名称 2.3. 命名方式要保持一致 2.4. 函数参数 2.5. 动词与关键词 2.6. 输出参数 2.7. 分隔指令与询问 2.8. 结构化编程 2.9. 如何写出心目中的函数 3. 注释 3.1. 好注释 4. 对象和数据结构 4.1. 数据抽象 4.2. 数据结构、对象的反对称性 4.3. LoD 5. 异常处理 5.1. 别传递null值 6. 附录 6.1. 名词 6.2. 动词 6.3. 形容词 1. 命名1.1. 代码简洁不代表模糊123456789/* * 不推荐 */uint8_t array[10];/* * 推荐 */uint8_t students_id[10]; 1.2. 有意义的变量名不要写a1，a2，a3，a，b，这样的变量名，除非在特定应用场景。 1.3. 避免使用编码或者前缀以前变量名带编码是因为编译器不会帮忙检查类型，要人工检查，现在编译器会帮忙检查类型，没必要增加冗余的东西。 12345678910111213/* * 不推荐 */uint32_t u32_student_id;uint8_t u8_student_weight;uint8_t *g_student_weight;uint8_t *g_student_height;/* * 推荐 */uint32_t student_id;uint8_t student_weight; 1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词我觉得在嵌入式行业会经常使用manager，controller等词，而每个人都会对它们有不同的定义，在不同场景它们也确实有不同的意义，所以就是会产生歧义和模糊性，除非对于这些名词有比较好的区分说明和规范，否则不太推荐使用，推荐使用大家能不产生歧义的名词。 1234567891011121314151617181920212223242526272829303132333435/* * 不推荐 */struct manager &#123; ...&#125;;struct processor &#123; ...&#125;;struct data &#123; ...&#125;;struct info &#123; ...&#125;;/* * 推荐 */struct student_info &#123; uint32_t weight; uint32_t height; ...&#125;;enum customer_hobbies &#123; FOOTBALL, BASKETBALL, ...&#125;;uint8_t dev_addr[6]; 2. 函数2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。123456789101112131415161718192021222324252627282930313233343536373839404142/* * 一个抽象层（发送数据），做一件事情（发数据），推荐 */void send_fifo_data(void *fifo)&#123; if (!is_fifo_empty(fifo)) &#123; send(fifo); &#125;&#125;/* * 两个抽象层（发送数据、fifo为空），做一件事情（发数据），不推荐 */void send_fifo_data(void *fifo)&#123; if (!is_fifo_empty(fifo)) &#123; if (first_elem_in_fifo(fifo) == 0xa5) &#123; send(fifo); &#125; &#125;&#125;/* * 两个函数，两个抽象层，做了两件事情，函数自顶向下，不窜层，推荐 */void send_fifo_data(void *fifo)&#123; if (is_fifo_valid(fifo)) &#123; send(fifo); &#125;&#125;uint8_t is_fifo_valid(void *fifo)&#123; if (is_fifo_empty(fifo)) &#123; return 0; &#125; if (first_elem_in_fifo(fifo) == 0xa5) &#123; return 1; &#125;&#125; 2.2. 使用描述性名称函数内容应该尽可能短，但是函数名称没限制，只要能把事情描述清楚，长一点没问题。 2.3. 命名方式要保持一致123456789101112131415/* * 推荐 */uint32_t get_year();uint32_t get_month();uint32_t get_day();uint32_t get_hour();/* * 不推荐 */uint32_t get_year();uint32_t month_get();uint32_t fetch_day();uint32_t read_hour(); 2.4. 函数参数个数越少越好，最好没有。 参数多会导致单元测试出现很多分支，覆盖率复杂。 如果参数多于3个，说明需要定义一个结构体了。 2.5. 动词与关键词12345678910/* * 一元函数，应该遵循：动词/名词结构比较好。 */void write(void *name)void write_field(void *name)/* * 二元函数，参数包含在函数名内，可以防止我们对于参数输入顺序出错，也是不错的选择 */void is_a_larger_b(void *a, void *b); 2.6. 输出参数尽量避免输出过多参数，可以用对象参数或者返回值来替代。 123456789/* * len是希望读到buf的个数，p_len是实际读到buf的个数 */void read_bytes(void *fifo, void *buf, uint8_t len, void *p_len);/* * len是希望读到buf的个数，返回值是实际读到buf的个数 */uint32_t read_bytes(void *fifo, void *buf, uint8_t len); 2.7. 分隔指令与询问函数要么做什么事，要么回答什么事，不要两者兼得。 1234567891011121314151617181920/* * 设置名字属性，如果name已经存在，则返回1，否则返回0。（不推荐） */uint8_t set_attribute(void *name, void *val)&#123; if (name) &#123; return 1; &#125; name = val; return 0;&#125;/* * 分开两个函数比较合理，然后用以下形式实现。（推荐） */if (!is_attribute_exist(name)) &#123; set_attribute(name, val);&#125; 2.8. 结构化编程Edsger Dijkstra提出结构化编程，即每个函数，只能有一个入口和一个出口。 永远不能出现goto 循环中不能出现break和continue 每个函数只有一个return 这个原则用在复杂的大函数效果显著，在小函数可以适当出现return和break，但是goto还是不要出现。 2.9. 如何写出心目中的函数尝试 + 单元测试 + 提炼，循环上述步骤。 3. 注释3.1. 好注释 对意图的注释 12345678910111213void uart_receiver_fsm()&#123; uint8_t chr; if (is_fifo_not_empty(&amp;fifo)) &#123; chr = get_elem(&amp;fifo); /* * 当收到第一个字节时候便打开接收超时定时器， * 用于计算接收超时 */ timer_start(0); &#125;&#125; 阐释 12345678910111213/* * 当a==b的时候，compare返回0 */if (comapre(a, b) == 0) &#123; ...&#125;/* * 当a &gt; b(asc2)的时候，compare返回1 */if (comapre(a, b) == 1) &#123; ...&#125; 4. 对象和数据结构4.1. 数据抽象 抽象接口不是简单的取值器和赋值器 12345678910111213141516171819/* * 不推荐，battery对象的接口只是将能量数值以函数形式暴露， * 这里的几个接口函数就是简单取值器，没有太多抽象作用。 */typedef struct &#123; uint32_t remained_energy_in_mw; ...&#125; battery_t;uint32_t get_remained_energy_in_mw(battery_t *self);/* * 推荐，battery对象的接口将能量抽象成百分比形式， * 没有暴露具体数值和单位。 */typedef struct &#123; uint32_t remained_energy_in_mw; ...&#125; battery_t;uint32_t get_remained_percent_energy(battery_t *self); 要以最好的形式呈现对象的数据，不能随意加取值期和赋值器。 4.2. 数据结构、对象的反对称性 过程式代码：暴露数据结构细节，便于在不改动数据结构基础上增添函数。 面向对象式代码：隐藏数据结构细节，便于在不改动函数的基础上增添新类。 过程式代码难修改数据结构，因为这样需要修改全部函数。面向对向式代码难修改函数，因为这样需要修改全部类。所以需要根据实际情况权衡什么时候使用哪种代码。 混杂对象和数据结构 混杂增加了添加新函数的难度，也增加了添加数据结构的难度，两面都不讨好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/* * 推荐，过程式代码，数据结构暴露数据，不提供有意义的函数 * 优势：添加/修改新的函数不会影响数据结构（比如增加计算形状周长函数） * 缺陷：修改数据结构影响所有函数（比如增加一个新的形状） */enum &#123; SQUARE, RECTANGLE, CIRCLE,&#125;;typedef struct &#123; uint8_t type; union &#123; ... &#125; ...&#125; shape_info_t;uint32_t get_area(shape_info_t *shape_info)&#123; switch (shape_info-&gt;type) &#123; case SQUARE: ... break; case RECTANGLE: ... break; case CIRCLE: ... break; &#125;&#125;/* * 推荐，面向对象式代码，隐藏数据，暴露操作数据的函数（shape_get_area） * 优势：添加/修改新的数据结构很简单（比如增加一个长方形），对原来的函数没有任何影响。 * 缺陷：如果需要增加一个获取形状周长的函数，那么全部形状都需要修改。 * NOTE：这里的关系是is a，如果是has a关系，那么结构体变量类型shape_t应该是shape_t * */#define PI 3.1415926typedef uint32_t (*pfn_get_area_t)(void);typedef struct &#123; pfn_get_area_t get_area;&#125; shape_t;typedef struct &#123; shape_t shape_ops; uint32_t r; &#125; circle_t;typedef struct &#123; shape_t shape_ops; uint32_t side; &#125; square_t;static uint32_t __cicrle_get_area(void)&#123; return PI * r * r;&#125;static uint32_t __square_get_area(void)&#123; return side * side;&#125;circle_t c1 = &#123; .shape_ops = __cicrle_get_area,&#125;;square_t s1 = &#123; .shape_ops = __square_get_area,&#125;;uint32_t shape_get_area(shape_t *shape)&#123; return shape-&gt;get_area();&#125;void main()&#123; shape_get_area((shape_t *)&amp;c1); shape_get_area((shape_t *)&amp;s1); &#125;/* * 不推荐，一半对象，一半数据结构，既拥有函数，又拥有公共变量。 * 缺陷：添加新函数难，添加新数据结构难。 * 如果需要添加形状（即公共变量改变），则访问公共变量的函数都要修改 * 如果需要新增一个获取周长的抽象方法（即增加执行函数），则所有形状对象都要修改 */enum &#123; SQUARE, RECTANGLE, CIRCLE,&#125;;typedef struct &#123; uint8_t type; uint8_t color_var1; uint8_t color_var2;&#125; shape_info_t;typedef uint32_t (*pfn_get_color_t)(void);typedef struct &#123; shape_info_t shape_info; //公共变量 pfn_get_color_t get_color; //执行函数&#125; shape_t;typedef struct &#123; shape_t shape; uint32_t r; &#125; circle_t;typedef struct &#123; shape_t shape; uint32_t side; &#125; square_t;static uint32_t __circle_get_color(void)&#123; return color_val1 * color_val2;&#125;static uint32_t __square_get_color(void)&#123; return color_val1 + color_val2;&#125;uint8_t shape_get_color(shape_t *shape)&#123; return shape-&gt;get_color();&#125;uint32_t shape_get_area(shape_t *shape)&#123; /* * 访问公共变量 */ switch (shape-&gt;shape_info.type) &#123; case SQUARE: ... break; case RECTANGLE: ... break; case CIRCLE: ... break; &#125;&#125;circle_t c1 = &#123; .shape_info.type = CIRCLE, ...&#125;;square_t s1 = &#123; .shape_info.type = SQUARE, ...&#125;;void main()&#123; shape_get_color((shape_t *)&amp;c1)) shape_get_area((shape_t *)&amp;c1))&#125; 4.3. LoDLaw of demeter认为，模块不应该了解它所操作对象的内部情形。 火车失事（只关乎于编码风格，像火车一样的代码） 12345678910111213141516/* * 不推荐，像火车一样的代码 */output_dir = ctxt.get_options().get_scratch_dir().get_abs_path();/* * 推荐（对象） */ops = ctxt.get_options();scratch_dir = ops.get_scratch_dir();abs_path = scratch_dir.get_abs_path();/* * 如果ctxt、ops等只是单纯数据结构，而不是对象则没有违反LoD */output_dir = ctxt.ops.scratch_dir.abs_path 5. 异常处理5.1. 别传递null值调用者可能会意外传入null，自己写代码时候应该不写可以传入null的函数，这样只要发现函数列表中有null就是出问题了。 6. 附录概念解释的来源主要有 百度翻译中的牛津词典 google翻译 stackoverflow高赞答案 wikidiff.com 笔者理解 其他地方 6.1. 名词 acknowledge 解释：确认帧/应答 缩写：ack 关联词：nack address 解释：地址 缩写：addr amount 解释：合计总量，表示量 关联词：number argument 解释：Argument is the actual value of this variable that gets passed to function. 缩写：arg 关联词：parameter12345void foo(void *param);...uint8_t arg1[] = "this is my argument";foo(arg1); attribute 解释：强调事物固有的属性，或区别其他事物的特征。比如车是红色，某某品牌 缩写：attr 关联词：property backup 解释：备份 缩写：bk buffer 解释：短暂数据存储的地方 缩写：buf 关联词：fifo callback 解释：邀请返回做某事，带点因果关系的意思。 缩写：cb 关联词：handler case 解释：具体情况/事例/特殊情况 command 解释：命令/指令 缩写：cmd 关联词：event content 解释：所含之物/内容 context 解释：事情发生的背景/上下文环境 data 解释：存储在计算机中的资料/原始数据/调查资料/材料 同义词：information/results/statistics device 解释：用于做某项工作的对象或者仪器 缩写：dev driver 解释：software that controls the sending of data between a computer and a piece of equipment that is attached to it, such as a printer event 解释：发生的事情 缩写：evt fail 解释：失败 field 解释：字段/信息组 fifo 解释：先进先出算法/先进先出缓冲区 关联词：lifo frame 解释：帧有格式，包括帧头+数据部分+帧尾 关联词：pakcet header 解释：帧头 缩写：hdr handle 解释：事物控制的部分 缩写：hdl handler 解释：处理某些事物的人 缩写：hdlr identity 解释：身份/本体 缩写：id information 解释：事实/某些事物的细节 缩写：info kind 解释：a group of people or things that are the same in some way; a particular variety or type，如某个种类的音乐。 关联词：type length 解释：长度/距离/持续时间的长短 缩写：len message 解释：（书面或口头的）信息，消息，音信 缩写：msg nack 解释：表示报文有错误，要求重发。 关联词：ack/syn master 解释：具有控制力的角色 关联词：slave number 解释：一个符号，代表数字/序号/数，表示数 缩写：num 关联词：amount packet 解释：a piece of information that forms part of a message sent through a computer network 缩写：pkt 关联词：frame/payload parameter 解释：Parameter is variable in the declaration of function 缩写：param payload 解释：有效载荷，是frame中的一部分 property 解释：强调“拥有”的参数，比如车有颜色属性，有尺寸大小属性。 关联词：attribute receiver 解释：接收者 缩写：rx remainder 解释：a part, number, or quantity that is left over. report 解释：新闻/报告 request 解释：(正式礼貌的)请求和要求的事 缩写：req response 解释：(口头或书面的)回复/响应 缩写：rsp result 解释：后果/结果 缩写：res self 解释：指向当前类的指针 关联词：this slave 解释：受控制的角色 关联词：master sender 解释：邮寄人 size 解释：抽象大小概念/标定大小尺寸 status 解释：(进展中的)状况/情形 string 解释：字符串，带’\0’结尾。 缩写：str 关联词：bytes succeess 解释：成功 syn 解释：在发消息之前，需要先同步。（tcp） 关联词：ack/nack this 解释：指向当前对象的指针 关联词：self transmitter 解释：发射机/发射者 缩写：tx 关联词：sender/receiver type 解释：a class or group of people or things that share particular qualities or features and are part of a larger group，如不同的人种 关联词：kind value 解释：由代数项表示的数值、数量 缩写：val 关联词：data variable 解释：可变因素 缩写：var version 解释：版本 缩写：vers manager 解释：待定 processor 解释：待定 controller 解释：待定 block 解释：由sector组成 sector 解释：由page组成 page 解释：SPI FLASH最小写操作单元 关于setting/option/preference/property/configuration的理解： Someone style: Settings: “View or modify the list of things that can be set” Options: “We have set some things already, and give you the option to enable or disable them” Preferences: “Tell us how you prefer this to work” Properties: “Change one or more properties of this item” Configuration: “We have defaults, but they’re so barebones you probably want to configure it yourself” Following an approximate lead from Visual Studio and other Microsoft products: Properties represent the characteristics of a single component or object in the application. Options alter global ways that the application works. Microsoft products use this to customise the UI toolbar, for example. There’s an implication here that you can disable UI elements altogether (e.g. a “Simple” user interface or an “Advanced” user interface). Settings and Preferences change qualities of how the application works. The implication here is to change, not disable: for example, “Metric measurements” or “British Imperial measurements”. Configuration is often where an application is customised for each user or group. 知乎： Configure some options in the settings. 程序所有的可变项叫做Settings。中文译作设置。所有的设置都是 “可选项”，Option（选项，不是期权），因为在程序世界里没有真的 开放式问题只有选择题（Option）。改变可选项的过程叫做 Configure配置（动词）。 附赠：已确定的Configure结果叫做Configuration配置（名词） 。Configure和Configuration都经常缩写为Config。一套既成的可 迁移的实现特定目的的Configuration叫做Profile，例如手机里的 静音Profile、仅震动Profile、蓝牙各种profile。 6.2. 动词 持久层/数据库操作 create 创建新的记录 read 读已存在的记录 update 更新已存在的记录 delete 删除已存在的记录 整体和个体的访问操作 put 将对象或者任意数据存进去（对象大小由sizeof决定） get 将对象或者任意数据读出来（对象大小由sizeof决定） write 将n个字节写进去 read 将n个字节读出来 恢复/复原/重置 recover 解释：从备份中获取部分文件 restore 解释：从备份中获取整个系统 refresh 解释：重装系统，但是保留应用程序和个人设置文件 reset 解释：重装系统，删除所有东西 缩写：rst 查询/寻找/搜索 inquire 解释：在某个范围内查询某指定事物（ask sth） find 解释：偶然遇到或者发现特定事物 search 解释：I searched on the internet. I found what I was looking for.（指定性没那么强） 过滤/拦截/排列 filter 解释：pass (a liquid, gas, light, or sound) through a device to remove unwanted material. 关联词：filter（名词） intercept 解释：to stop sb/sth that is going from one place to another from arriving 关联词：interceptor（名词） sort 解释：按顺序排列 学习/研究/分析 study learn research 解释：不断寻找和检查来研究某事物 analyze 解释：对当前主题进行分析 覆盖 cover 解释：把某事物放在某事物上面，如隐藏和保护 overlap 解释：延伸并部分覆盖或者替代掉某物 固定搭配 fetch 解释：获取东西 关联词：store store 解释：将东西保存起来以备以后使用 关联词：fetch start 解释：较随意的开始/创立 stop 解释：较随意的结束 begin 解释：从头开始 end 解释：终点结束 enter 解释：加入/进入/开始从事/开始活动 exit 解释：退出（计算机程序） open 解释：参考文件系统使用方法 close 解释：参考文件系统使用方法 input 解释：第三人称描述某个事物的输入 关联词：receive（第一人称） output 解释：第三人称描述某个事物的输出 关联词：transmit（第一人称） upload 解释：上传到服务器或者别的电脑 download 解释：从服务器或者别的电脑下载 set 解释：设置 clear 解释：清除 缩写：clr init 解释：是一个实例的初始化方法 deinit 解释：释放内存 plus 解释：加法 minus 解释：减法 subscribe 解释：订阅 缩写：subs publish 解释：发布 缩写：pub add 解释：增加某东西 sub 解释：减去某东西 pend 参考操作系统 post 参考操作系统 error 解释：err 缩写： ok 解释： 缩写： append 解释：在结尾插入内容 calculate 解释：计算 缩写：calc contain 解释：包含/含有/容纳 erase 解释：flash专用 indicate 解释：指示 关联词：confirm initialize 解释：类的方法，在所有实例方法和类方法执行前运行 notify 解释：正式通报，通知 implement 解释：实现 缩写：impl remove 解释：拿走，但内存还在 关联词：delete（删除释放内存）、recover transfer 解释：移交/转移 translate 解释：转变/变为 overflow 解释：溢出某个容器 peek 解释：偷看一眼 process 解释：对data作一些的操作或处理 6.3. 形容词 固定搭配 valid 解释：有效的 invalid 解释：无效的 busy 解释：忙 idle 解释：空闲 used 解释：已使用 unused 解释：没用着的/空闲的 描述真实/真的 actual 解释：形容客观存在的事实或者行为 real 解释：真实的/实际存在的，对真理的描述 描述大小 larger 解释：强调体积/能力/数量 bigger 解释：表示由“重”的意思，重要/重量。 smaller 解释：无关紧要的/小的数量 little 解释：小的尺寸/只有一点点 tiny 解释：极小的/微小的/微量的 different 解释：不同 缩写：diff equal 解释：大小、价值、数量相等或相同 expected 解释：预料的/预期的 initial 解释：初始化的 remain 解释：仍然存在/可以使用/还没被处理 temp 解释：临时 缩写：tmp]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>代码</tag>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cm_backtrace学习笔记]]></title>
    <url>%2F2019%2F05%2F24%2Fcm-backtrace%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[龙神的debug组件学习笔记。 前言最近了解cortexM的hardfault回溯，记得之前有前辈写过一个组件，趁这次机会拜读一下，并且记录下学习过程。 cmb_fault.s汇编文件组件支持IAR/KEIL/GNU，因为最近用到KEIL，所以就直接看KEIL的汇编文件了，下面摘取了一部分的代码。之前对这块没有好好的总结过，所以这次简单总结一下。 AREA |.text|, CODE, READONLY, ALIGN=2 THUMB REQUIRE8 PRESERVE8 ; NOTE: If use this file&apos;s HardFault_Handler, please comments the HardFault_Handler code on other file. IMPORT cm_backtrace_fault EXPORT HardFault_Handler HardFault_Handler PROC MOV r0, lr ; get lr MOV r1, sp ; get stack pointer (current is MSP) BL cm_backtrace_fault Fault_Loop BL Fault_Loop ;while(1) ENDP END 源码实现的功能： 当hardfault发生时，将lr和sp作为参数传递给cm_backtrace_fault； cm_backtrace_fault处理完之后，进入死循环。 QA：Q：AREA |.text|, CODE, READONLY, ALIGN=2的意义？ AREA：asm指令，参考DUI0379G_02_mdk_armasm_user_guide文档 |.text|：|.text| is used for code sections produced bythe C compiler, or for code sections otherwise associated with the C library. CODE：Contains machine instructions. READONLY is the default READONLY：Indicates that this section must not be written to. This is the default for Code areas. ALIGN=2：By default, ELF sections are aligned on a four-byte boundary. expression can haveany integer value from 0 to 31. The section is aligned on a 2expression-byte boundary. Forexample, if expression is 10, the section is aligned on a 1KB boundary.This is not the same as the way that the ALIGN directive is specified. Q：为什么需要4字节对齐？我也不知道 Q：THUMB的意义？ 参考《DUI0379G_02_mdk_armasm_user_guide》有还怎么一些话 The THUMB directive instructs the assembler to interpret subsequent instructions as Thumb instructions,using the UAL syntax. In files that contain code using different instruction sets, THUMB must precede Thumb code written inUAL syntax. 《The Definitive Guide to theARM Cortex-M0》有这么一段话： Be careful with legacy Thumb programs that use the CODE16 directive. When the CODE16directive is used, the instructions are interpreted as traditional Thumb syntax. For example,data processing op-codes without S suffixes are converted to instructions that updateAPSR when the CODE16 directive is used. However, you can reuse assembly files with theCODE16 directive because it is still supported by existing ARM development tools. Fornew assembly code, the THUMB directive is recommended, which indicates to the assemblythat the Unified Assembly Language (UAL) is used. With UAL syntax, data processinginstructions updating the APSR require the S suffix. Q：REQUIRE8和PRESERVE8的意义？ 《The Definitive Guide to theARM Cortex-M0》有这么一段话： In ARM/Keil development tools, the assembler provides the REQUIRE8 directive to indicate ifthe function requires double-word-stack alignment and the PRESERVE8 directive to indicatethat a function preserves the double-word alignment. This directive can help the assemblerto analyze your code and generate warnings if a function that requires a double-word-alignedstack frame is called by another function that does not guarantee double-word-stack alignment.Depending on your application, these directives might not be required, especially for projectsbuilt entirely with assembly code. 栈帧回溯功能分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * backtrace function call stack * * @param buffer call stack buffer * @param size buffer size * @param sp stack pointer * * @return depth */size_t cm_backtrace_call_stack(uint32_t *buffer, size_t size, uint32_t sp) &#123; ... /* copy called function address */ for (; sp &lt; stack_start_addr + stack_size; sp += sizeof(size_t)) &#123; /* the *sp value may be LR, so need decrease a word to PC */ /* * 假设用户调用了这么一段断言代码： * * void usr_assert(uin8_t zoo) * &#123; * uint32_t sp = cmb_get_msp(); * cm_backtrace_assert(sp); * foo(zoo); * &#125; * * 那么在进入cm_backtrace_assert的时候，会将foo的地址写进LR，然后将 * LR进栈，所以SP指向LR，LR-4刚好就是cm_backtrace_assert的地址 * (因为BL跳转指令刚好占4个字节）。 * 然后从该地址开始轮询已经入栈的数据，看看被压栈里的地址哪个是在代码区 * 间内的，找到就将他们保存进buffer。 * * 这里的回溯原理：找到调用栈中在代码区间内的地址 * 需要注意：code_start_addr和code_size是否定义正确，决定了是否能正 * 确找到调用的函数地址，这个和分散加载（链接脚本）有密切关系。 */ pc = *((uint32_t *) sp) - sizeof(size_t); /* the Cortex-M using thumb instruction, so the pc must be an odd number */ if (pc % 2 == 0) &#123; continue; &#125; if ((pc &gt;= code_start_addr) &amp;&amp; (pc &lt;= code_start_addr + code_size) &amp;&amp; (depth &lt; CMB_CALL_STACK_MAX_DEPTH) &amp;&amp; (depth &lt; size)) &#123; /* the second depth function may be already saved, so need ignore repeat */ if ((depth == 2) &amp;&amp; regs_saved_lr_is_valid &amp;&amp; (pc == buffer[1])) &#123; continue; &#125; buffer[depth++] = pc; &#125; &#125; return depth;&#125; 参考资料 《The Definitive Guide to theARM Cortex-M0》 《DUI0379G_02_mdk_armasm_user_guide》 《DUI0497A_cortex_m0_r0p0_generic_ug》 《DDI0419C_arm_architecture_v6m_reference_manual》]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>hardfault</tag>
        <tag>cortex</tag>
        <tag>debug</tag>
        <tag>栈帧回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE安全机制从入门到放弃]]></title>
    <url>%2F2019%2F05%2F14%2FBLE%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。 前言标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。 为了易于理解，会对蓝牙核心规范的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范。 最后，这是博主的一得之见，欢迎各位指正。 目录 密码技术初探 对称密码 diffie-hellman密钥交换算法 椭圆曲线diffie-hellman密钥交换算法 消息认证码 认证加密CCM 信息安全小结 ble安全机制初探 ble40安全机制 ble42安全机制 总结 参考资料 密码技术初探在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。 重要角色一览表 Alice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：从账户B-6789向账户A-1234汇款500元。 当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成： Eve 窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。 Mallory： 篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。 伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。 从上述例子可知消息面临的威胁有：窃听、篡改和伪装，对应的安全特性为：机密性、一致性、是否已认证。 “威胁”和“安全特性”的关系可以这样描述： 如果消息没有加密，消息则不具有机密性，无法防止他人窃听； 如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性； 如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。 存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。 对称密码算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。 所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。 对称密码应用图 对称密码解决的问题 如上图所示 Bob创建一条汇款请求消息； 用密钥key对它加密； 将加密后的消息发给Alice； Alice收到密文； Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容； Alice用密钥key对消息解密； Alice获得一条汇款请求消息。 对称密码技术可以解决窃听的威胁。 对称密码无法解决的问题 对称密码技术可以解决窃听的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式： Bob通过网络先将key发送给Alice，但容易被Eve截取到； Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送； 用diffie-hellman密钥交换算法解决； 用椭圆曲线diffie-hellman密钥交换算法解决。 diffie-hellman密钥交换算法先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？ 密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。 最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。 离散对数问题 背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。 现有离散对数问题如下，请问满足公式的x是多少： 为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。 例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论： 对于上图公式，已知G、p、Y的时候，很难求出x。 接下来我们看看如何具体利用这个数学问题来协商出密钥的。 diffie-hellman密钥交换算法应用 在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。 DH应用图 如上图所示 Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p； Bob和Alice分别随机生成各自的私钥sb和sa； Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa； Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa； Bob和Alice计算出共享密钥DHkey。 Eve能计算出DHkey吗？ 对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。 diffie-hellman密钥交换算法解决的问题 因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。 椭圆曲线diffie-hellman密钥交换算法DH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。 两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。 椭圆曲线diffie-hellman密钥交换算法应用 ECDH中的数学问题可以这样简单定义： 已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号*表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。 在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。 ECDH应用图 如上图所示 Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G； Bob和Alice分别随机生成各自的私钥sb和sa； Bob和Alice根据G以及各自的私钥，生成公钥pb和pa； Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa； Bob和Alice计算出共享密钥DHkey。 椭圆曲线diffie-hellman密钥交换算法无法解决的问题 DH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被窃听了，但是对于篡改和伪装的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。 篡改示意图 如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。 伪装示意图 如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。 消息认证码消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。 MAC技术有以下几种重要性质： 正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。 逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。 输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。 冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。 MAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。 消息认证码解决的问题 消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？ 消息一致性检查和认证示意图 Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。 Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。 消息认证码无法解决的问题 没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。 消息认证码攻击方式 对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。 认证加密CCM其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止窃听，认证能防止篡改和伪装。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。 通过查阅资料，以我的战五渣水平只能理解到这一程度： 发送方先对明文使用MAC技术，然后对称加密成密文； 接收方先用对称加密技术解密密文，然后用MAC技术校验明文； 发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。 个人猜测CCM应用示意图 上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。 放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。 信息安全小结威胁、安全特性、密码技术关系图 总结： 为了解决窃听问题，采用对称密码技术； 为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术； 为了解决篡改问题，采用消息认证码技术； 为了解决伪装问题，采用消息认证码技术； 为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。 Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。 ble安全机制初探在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。 ble重要角色一览表 背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异： 建立连接前 主机能进入扫描状态、发起连接状态，不能进入广播状态； 从机能进入广播状态，不能进入扫描状态和发起连接状态； 一定是由主机发起连接，从机只能被连接。 建立连接后 一定是由主机发起配对，但是从机能够请求主机发起配对； ble各个状态示意图 广播状态：设备正在往空中发送广播包，谁都可以收得到； 扫描状态：设备正在接收空中的广播包，看看谁在发，发什么； 发起连接状态：设备指定与另外一个设备发起连接； 明文数传阶段：两个已连接设备之间，用明文传送数据包； 配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥； 加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，衍生出最终用于加密底层数据包的密钥； 密文数传阶段：两个已连接设备之间，用密文传送数据包； 绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。 除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解： 复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。 连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。 ble40安全机制从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？ ble4.0安全机制简单示意图 上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。 对于密文数传，ble提供解决方案分四种情况： 首次连接无绑定 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 首次连接有绑定 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。 第二次连接且首次连接无绑定 第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 第二次连接且首次连接有绑定 第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 由下往上读图，回答用户提出的问题： ble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。 TK配对码的生成和配送 ble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异： JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。 Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob’s User，Bob’s User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。 下面来看一下图，Passkey模式是怎么做到认证保护的。 认证保护示意图 通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。 分两种攻击行为 篡改MIC或者明文其中一项，属于篡改攻击。 如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。 如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。 同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。 因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。 ble4.0真的足够安全吗？ 我们先列出ble4.0安全机制各个密钥的安全依赖关系： CCM -&gt; sessionKey -&gt; STK(LTK) -&gt; TK 可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。 一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。 而实际TK的取值是000000~999999，最多只有100万种可能性，先抓取配对阶段（phase2.2）中用到的明文、MIC，再通过穷举的方式，就可以推算出TK了。 我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。 Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。 如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。 Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改； Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改； 伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。 如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。 Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改； Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改； 伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。 总结出几个观点： 因为“加密”都依赖于认证码TK，而TK容易被穷举破解，加密则形同虚设。 上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。 TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。 上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题。 ble42安全机制上一节，我们分析了ble4.0的安全“漏洞”， 接下来简单说一下ble4.2作出的应对措施。 无法改变的前提： 配对码是6个字节。 可能的攻击方式： Eve窃听整个过程，从而破解TK，下一次可以伪装Bob和Alice主动发起连接认证。 Eve窃听整个过程，从而破解TK，从而得到STK，然后窃取LTK。 Mallory发起MITM攻击，即使攻击失败，包含整个TK信息的MAC和MIC会被Mallory获得。（虽然我不知道有什么用） 提出对应解决的方案： 动态认证码； ECDH保证机密性； 将TK拆成20bit，每次认证一个bit，攻击失败只会暴露1个bit，不会暴露整个TK。 BLE4.2与BLE4.0的安全机制区别主要体现在“配对阶段”的phase2，在这个阶段引入了ECDH，下面展开passkey模式的phase2（包括phase2.1~2.3）。 BLE4.2 phase2示意图 在“Authentication Stage1”过程，可以发现Bob和Alice只在空中交互了三次，所以Mallory的攻击时机有三个： 交换公钥的时刻 交换MIC的时刻 交换明文的时刻。 后两个攻击方式，在BLE4.0已经分析过了，至于第一个攻击时机，因为公钥是也是MAC算法里面的一个参数，所以它也不能被随意篡改，如果改了后面的Ea和Eb校验就不通过了，即给ECDH也提供了MITM保护。 Tips：这里之所以可以提供MITM保护的实质是人的参与，通过观察的方法获得配对码，绕开了蓝牙空中传输来获得配对码，从而不会受到第三者攻击。 对比BLE4.2和BLE4.0的主要区别： BLE4.2没有STK，在配对过程直接生成LTK，因为LTK在配对阶段就已经强制生成了，加密过程直接使用LTK，BLE4.2的绑定阶段(phase3)不会发送LTK。 LTK是DHkey衍生出来的，DHkey是第三方无法窃听也无法破解出来的，所以可以保证后面用CCM加密后数据的机密性。 BLE4.2完美解决了BLE4.0的安全漏洞。 总结文章提到的只是BLE常见的一些概念，其他如：签名（Signed）、授权（Authorization）之类都没有提及，有兴趣的读者可以去核心规范探索一番。 参考资料里面有许多优秀的书籍和文章，比如密码技术相关知识我是从《图解密码技术》获知的，关于具体的实战抓包分析，吹爆“BLE配对过程详解”这篇文章。 最后最后，感谢您阅读到最后，这是对我最大的鼓励，也希望这篇博文能让您有一点点的收获。 后记一开始是想将MESH加进来的，但是考虑到还没上过正式的项目去体验过，怕写出来理解的不够透彻，所以还是算了，以后有机会再单独开一篇吧，但是有兴趣的朋友可以私底下一起交流。 参考资料 《图解密码技术》 BLE配对过程详解 BLE核心规范 Hash算法总结 穷举法破解BLE的TK值]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>BLE</tag>
        <tag>安全机制</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建实战]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。 目录 配置主题 配置风格 配置语言 配置描述 配置目录 配置头像 配置拉条 配置社交 配置打赏 配置菜单 配置标签 配置分类 配置评论 配置分享 配置版权 配置脚注 配置统计 配置搜索 博文置顶 博文插图 配置主题修改博客工程根目录下的_config.yml文件 theme: hexo-theme-next 配置风格修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 scheme: Mist 配置语言修改博客工程根目录下的_config.yml文件 language: zh-CN 配置描述修改博客工程根目录下的_config.yml文件 description: &quot;Stay hungry, Stay foolish.&quot; 配置目录修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 toc: enable: true number: false 配置头像将头像图片文件123.jpg放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 avatar: url: /images/123.jpg 配置拉条none 配置社交修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 social: GitHub: https://github.com/jaydenh215 || github 配置打赏将打赏图片文件wechatpay.jpg放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 reward_settings: enable: true comment: “如果觉得还不错，请我喝杯咖啡吧~” reward: wechatpay: /images/wechatpay.jpg 配置菜单修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 menu: home: / || home tags: /tags/ || tags categories: /categories/ || th 配置标签增加一个页面（page）用来汇总标签 hexo new page tags 修改生成的页面文件内容（/source/tags/index.md） --- title: tags date: 2019-05-10 13:49:39 type: &quot;tags&quot; --- 给文章添加标签属性 --- title: 博客个性化配置 date: 2019-05-10 10:00:00 tags: - 博客 - 搭建 - 环境 - 配置 --- 配置分类增加一个页面（page）用来汇总类别 hexo new page categories 修改生成的页面文件内容（/source/categories/index.md） --- title: categories date: 2019-05-10 13:44:06 type: &quot;categories&quot; --- 给文章添加类别属性 --- title: 博客个性化配置 date: 2019-05-10 10:00:00 categories: - 社交 --- 配置评论next主题集成了许多第三方厂家的评论功能插件，选择比较精简的Valine。 修改主题目录（/themes/hexo-theme-next）下的_config.yml文件，主要是app id和app key。 valine: enable: true appid: xxxxxxxxxx appkey: xxxxxxxxxx guest_info: nick,mail notify: true placeholder: Comment here ... 增加评论区之后，右下角会有Power by Valine，可以这样删掉： 找到/themes/hexo-theme-next/layout/_third-party/comments/valine.swig文件并修改代码 修改前： &lt;script&gt; var GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;]; var guest = &apos;{{ theme.valine.guest_info }}&apos;; guest = guest.split(&apos;,&apos;).filter(function(item) { return GUEST.indexOf(item) &gt; -1; }); new Valine({ el: &apos;#comments&apos;, verify: {{ theme.valine.verify }}, notify: {{ theme.valine.notify }}, appId: &apos;{{ theme.valine.appid }}&apos;, appKey: &apos;{{ theme.valine.appkey }}&apos;, placeholder: &apos;{{ theme.valine.placeholder }}&apos;, avatar: &apos;{{ theme.valine.avatar }}&apos;, meta: guest, pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10, visitor: {{ theme.valine.visitor }}, lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos; }); &lt;/script&gt; 修改后： &lt;script&gt; var GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;]; var guest = &apos;{{ theme.valine.guest_info }}&apos;; guest = guest.split(&apos;,&apos;).filter(function(item) { return GUEST.indexOf(item) &gt; -1; }); new Valine({ el: &apos;#comments&apos;, verify: {{ theme.valine.verify }}, notify: {{ theme.valine.notify }}, appId: &apos;{{ theme.valine.appid }}&apos;, appKey: &apos;{{ theme.valine.appkey }}&apos;, placeholder: &apos;{{ theme.valine.placeholder }}&apos;, avatar: &apos;{{ theme.valine.avatar }}&apos;, meta: guest, pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10, visitor: {{ theme.valine.visitor }}, lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos; }); //新增 var infoEle= document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0) { infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); }); } &lt;/script&gt; 配置分享修改博客工程根目录下的_config.yml文件 baidushare: true 修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 baidushare: type: button 按照链接中的方法，将static放进/themes/hexo-theme-next/source目录下。 修改baidushare.swig文件中的代码。 修改前： .src=&apos;//bdimg.share.baidu.com/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; 修改后： .src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; 配置版权修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 creative_commons: post: true 修改博客工程根目录下的_config.yml文件 url: https://jaydenh215.github.io/ 配置脚注修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 footer: powered: enable: false theme: enable: false 配置统计next主题集成了许多第三方厂家的统计功能插件，选择LeanCloud。 完成上述步骤之后，会发现阅读次数后面没有数字，那是因为LeanCloud和next主题还没有联系起来，需要按照该博主的方法来实现。 部署云引擎以保证访客数量不被随意篡改 20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。 配置搜索next主题推荐使用Local Search 博文置顶参考这里 博文插图修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 post_asset_folder: true 这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。 为了去掉插图的边框，找到/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl文件并修改代码。 img { box-sizing: border-box; margin: auto; padding: 0px; border: 0px; }]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>搭建</tag>
        <tag>配置</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
